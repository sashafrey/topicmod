// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "internals.rpcz.h"
#include "internals.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/stubs/once.h>
#include <rpcz/rpcz.hpp>
namespace {
const ::google::protobuf::ServiceDescriptor* MasterComponentService_descriptor_ = NULL;
const ::google::protobuf::ServiceDescriptor* NodeControllerService_descriptor_ = NULL;
}  // anonymouse namespace

namespace artm {
namespace core {

void rpcz_protobuf_AssignDesc_internals_2eproto() {
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "internals.proto");
  GOOGLE_CHECK(file != NULL);
  MasterComponentService_descriptor_ = file->service(0);
  NodeControllerService_descriptor_ = file->service(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &rpcz_protobuf_AssignDesc_internals_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
}

}  // namespace

void rpcz_protobuf_ShutdownFile_internals_2eproto() {
}

void rpcz_protobuf_AddDesc_internals_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::artm::protobuf_AddDesc_messages_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017internals.proto\022\tartm.core\032\016messages.p"
    "roto\"\037\n\nFloatArray\022\021\n\005value\030\001 \003(\002B\002\020\001\"\031\n"
    "\004Mask\022\021\n\005value\030\001 \003(\010B\002\020\001\"\025\n\004Bool\022\r\n\005valu"
    "e\030\001 \001(\010\"\024\n\003Int\022\r\n\005value\030\001 \001(\005\"\027\n\006String\022"
    "\r\n\005value\030\001 \001(\t\"\006\n\004Void\"\331\001\n\020DataLoaderCon"
    "fig\022\023\n\013instance_id\030\002 \001(\005\022\021\n\tdisk_path\030\003 "
    "\001(\t\022\026\n\nqueue_size\030\004 \001(\005:\00210\022\034\n\006stream\030\005 "
    "\003(\0132\014.artm.Stream\022\035\n\017compact_batches\030\006 \001"
    "(\010:\004true\022%\n\026cache_processor_output\030\007 \001(\010"
    ":\005false\022!\n\031master_component_endpoint\030\010 \001"
    "(\t\"s\n\016InstanceConfig\022\033\n\020processors_count"
    "\030\002 \001(\005:\0011\022!\n\031master_component_endpoint\030\003"
    " \001(\t\022!\n\025merger_queue_max_size\030\004 \001(\005:\00210\""
    "\322\001\n\016ProcessorInput\022\032\n\005batch\030\001 \002(\0132\013.artm"
    ".Batch\022\022\n\nbatch_uuid\030\002 \002(\t\022\026\n\016data_loade"
    "r_id\030\003 \002(\005\022$\n\013stream_mask\030\004 \003(\0132\017.artm.c"
    "ore.Mask\022\023\n\013stream_name\030\005 \003(\t\022=\n\031previou"
    "s_processor_output\030\006 \001(\0132\032.artm.core.Pro"
    "cessorOutput\"q\n\017ProcessorOutput\022\022\n\nbatch"
    "_uuid\030\001 \002(\t\022\026\n\016data_loader_id\030\002 \002(\005\0222\n\017m"
    "odel_increment\030\003 \003(\0132\031.artm.core.ModelIn"
    "crement\"\204\002\n\016ModelIncrement\022\020\n\010model_id\030\001"
    " \002(\t\022\024\n\014topics_count\030\002 \002(\005\022\027\n\017items_proc"
    "essed\030\003 \001(\005\022\030\n\020discovered_token\030\004 \003(\t\022\r\n"
    "\005token\030\005 \003(\t\022.\n\017token_increment\030\006 \003(\0132\025."
    "artm.core.FloatArray\022\r\n\005score\030\007 \003(\001\022\022\n\ns"
    "core_norm\030\010 \003(\001\022\017\n\007item_id\030\t \003(\005\022$\n\005thet"
    "a\030\n \003(\0132\025.artm.core.FloatArray\"\034\n\010BatchI"
    "ds\022\020\n\010batch_id\030\001 \003(\t\"S\n\034CreateOrReconfig"
    "ureModelArgs\022\020\n\010model_id\030\002 \001(\t\022!\n\006config"
    "\030\003 \001(\0132\021.artm.ModelConfig\"$\n\020DisposeMode"
    "lArgs\022\020\n\010model_id\030\002 \001(\t\"g\n\"CreateOrRecon"
    "figureRegularizerArgs\022\030\n\020regularizer_nam"
    "e\030\002 \001(\t\022\'\n\006config\030\003 \001(\0132\027.artm.Regulariz"
    "erConfig\"2\n\026DisposeRegularizerArgs\022\030\n\020re"
    "gularizer_name\030\002 \001(\t2\345\002\n\026MasterComponent"
    "Service\022:\n\013UpdateModel\022\031.artm.core.Model"
    "Increment\032\020.artm.TopicModel\0224\n\rRetrieveM"
    "odel\022\021.artm.core.String\032\020.artm.TopicMode"
    "l\0225\n\016RequestBatches\022\016.artm.core.Int\032\023.ar"
    "tm.core.BatchIds\0225\n\rReportBatches\022\023.artm"
    ".core.BatchIds\032\017.artm.core.Void\0223\n\rConne"
    "ctClient\022\021.artm.core.String\032\017.artm.core."
    "Void\0226\n\020DisconnectClient\022\021.artm.core.Str"
    "ing\032\017.artm.core.Void2\335\004\n\025NodeControllerS"
    "ervice\022I\n\033CreateOrReconfigureInstance\022\031."
    "artm.core.InstanceConfig\032\017.artm.core.Voi"
    "d\0223\n\017DisposeInstance\022\017.artm.core.Void\032\017."
    "artm.core.Void\022M\n\035CreateOrReconfigureDat"
    "aLoader\022\033.artm.core.DataLoaderConfig\032\017.a"
    "rtm.core.Void\0225\n\021DisposeDataLoader\022\017.art"
    "m.core.Void\032\017.artm.core.Void\022T\n\030CreateOr"
    "ReconfigureModel\022\'.artm.core.CreateOrRec"
    "onfigureModelArgs\032\017.artm.core.Void\022<\n\014Di"
    "sposeModel\022\033.artm.core.DisposeModelArgs\032"
    "\017.artm.core.Void\022`\n\036CreateOrReconfigureR"
    "egularizer\022-.artm.core.CreateOrReconfigu"
    "reRegularizerArgs\032\017.artm.core.Void\022H\n\022Di"
    "sposeRegularizer\022!.artm.core.DisposeRegu"
    "larizerArgs\032\017.artm.core.Void", 2388);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "internals.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&rpcz_protobuf_ShutdownFile_internals_2eproto);
}

// ===================================================================

MasterComponentService::~MasterComponentService() {}

const ::google::protobuf::ServiceDescriptor* MasterComponentService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterComponentService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* MasterComponentService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterComponentService_descriptor_;
}

void MasterComponentService::UpdateModel(const ::artm::core::ModelIncrement&,
                         ::rpcz::reply< ::artm::TopicModel> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method UpdateModel() not implemented.");
}

void MasterComponentService::RetrieveModel(const ::artm::core::String&,
                         ::rpcz::reply< ::artm::TopicModel> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RetrieveModel() not implemented.");
}

void MasterComponentService::RequestBatches(const ::artm::core::Int&,
                         ::rpcz::reply< ::artm::core::BatchIds> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RequestBatches() not implemented.");
}

void MasterComponentService::ReportBatches(const ::artm::core::BatchIds&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method ReportBatches() not implemented.");
}

void MasterComponentService::ConnectClient(const ::artm::core::String&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method ConnectClient() not implemented.");
}

void MasterComponentService::DisconnectClient(const ::artm::core::String&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisconnectClient() not implemented.");
}

void MasterComponentService::call_method(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message& request,
                             ::rpcz::server_channel* channel) {
  GOOGLE_DCHECK_EQ(method->service(), MasterComponentService_descriptor_);
  switch(method->index()) {
    case 0:
      UpdateModel(
          *::google::protobuf::down_cast<const ::artm::core::ModelIncrement*>(&request),
          ::rpcz::reply< ::artm::TopicModel>(channel));
      break;
    case 1:
      RetrieveModel(
          *::google::protobuf::down_cast<const ::artm::core::String*>(&request),
          ::rpcz::reply< ::artm::TopicModel>(channel));
      break;
    case 2:
      RequestBatches(
          *::google::protobuf::down_cast<const ::artm::core::Int*>(&request),
          ::rpcz::reply< ::artm::core::BatchIds>(channel));
      break;
    case 3:
      ReportBatches(
          *::google::protobuf::down_cast<const ::artm::core::BatchIds*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 4:
      ConnectClient(
          *::google::protobuf::down_cast<const ::artm::core::String*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 5:
      DisconnectClient(
          *::google::protobuf::down_cast<const ::artm::core::String*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& MasterComponentService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::core::ModelIncrement::default_instance();
    case 1:
      return ::artm::core::String::default_instance();
    case 2:
      return ::artm::core::Int::default_instance();
    case 3:
      return ::artm::core::BatchIds::default_instance();
    case 4:
      return ::artm::core::String::default_instance();
    case 5:
      return ::artm::core::String::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& MasterComponentService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::TopicModel::default_instance();
    case 1:
      return ::artm::TopicModel::default_instance();
    case 2:
      return ::artm::core::BatchIds::default_instance();
    case 3:
      return ::artm::core::Void::default_instance();
    case 4:
      return ::artm::core::Void::default_instance();
    case 5:
      return ::artm::core::Void::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

MasterComponentService_Stub::MasterComponentService_Stub(::rpcz::rpc_channel* channel,
                                   const ::std::string& service_name,
                                   bool owns_channel)
  : channel_(channel), service_name_(service_name),
    owns_channel_(owns_channel) {}
MasterComponentService_Stub::MasterComponentService_Stub(::rpcz::rpc_channel* channel,
                                   bool owns_channel)
  : channel_(channel), service_name_(MasterComponentService::descriptor()->name()),
    owns_channel_(owns_channel) {}
MasterComponentService_Stub::~MasterComponentService_Stub() {
  if (owns_channel_) delete channel_;
}

void MasterComponentService_Stub::UpdateModel(const ::artm::core::ModelIncrement& request,
                              ::artm::TopicModel* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(0),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::UpdateModel(const ::artm::core::ModelIncrement& request,
                              ::artm::TopicModel* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(0),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::RetrieveModel(const ::artm::core::String& request,
                              ::artm::TopicModel* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(1),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::RetrieveModel(const ::artm::core::String& request,
                              ::artm::TopicModel* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(1),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::RequestBatches(const ::artm::core::Int& request,
                              ::artm::core::BatchIds* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(2),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::RequestBatches(const ::artm::core::Int& request,
                              ::artm::core::BatchIds* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(2),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::ReportBatches(const ::artm::core::BatchIds& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(3),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::ReportBatches(const ::artm::core::BatchIds& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(3),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::ConnectClient(const ::artm::core::String& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(4),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::ConnectClient(const ::artm::core::String& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(4),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::DisconnectClient(const ::artm::core::String& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(5),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::DisconnectClient(const ::artm::core::String& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(5),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
// ===================================================================

NodeControllerService::~NodeControllerService() {}

const ::google::protobuf::ServiceDescriptor* NodeControllerService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeControllerService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* NodeControllerService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeControllerService_descriptor_;
}

void NodeControllerService::CreateOrReconfigureInstance(const ::artm::core::InstanceConfig&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureInstance() not implemented.");
}

void NodeControllerService::DisposeInstance(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeInstance() not implemented.");
}

void NodeControllerService::CreateOrReconfigureDataLoader(const ::artm::core::DataLoaderConfig&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureDataLoader() not implemented.");
}

void NodeControllerService::DisposeDataLoader(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeDataLoader() not implemented.");
}

void NodeControllerService::CreateOrReconfigureModel(const ::artm::core::CreateOrReconfigureModelArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureModel() not implemented.");
}

void NodeControllerService::DisposeModel(const ::artm::core::DisposeModelArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeModel() not implemented.");
}

void NodeControllerService::CreateOrReconfigureRegularizer(const ::artm::core::CreateOrReconfigureRegularizerArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureRegularizer() not implemented.");
}

void NodeControllerService::DisposeRegularizer(const ::artm::core::DisposeRegularizerArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeRegularizer() not implemented.");
}

void NodeControllerService::call_method(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message& request,
                             ::rpcz::server_channel* channel) {
  GOOGLE_DCHECK_EQ(method->service(), NodeControllerService_descriptor_);
  switch(method->index()) {
    case 0:
      CreateOrReconfigureInstance(
          *::google::protobuf::down_cast<const ::artm::core::InstanceConfig*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 1:
      DisposeInstance(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 2:
      CreateOrReconfigureDataLoader(
          *::google::protobuf::down_cast<const ::artm::core::DataLoaderConfig*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 3:
      DisposeDataLoader(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 4:
      CreateOrReconfigureModel(
          *::google::protobuf::down_cast<const ::artm::core::CreateOrReconfigureModelArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 5:
      DisposeModel(
          *::google::protobuf::down_cast<const ::artm::core::DisposeModelArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 6:
      CreateOrReconfigureRegularizer(
          *::google::protobuf::down_cast<const ::artm::core::CreateOrReconfigureRegularizerArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 7:
      DisposeRegularizer(
          *::google::protobuf::down_cast<const ::artm::core::DisposeRegularizerArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& NodeControllerService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::core::InstanceConfig::default_instance();
    case 1:
      return ::artm::core::Void::default_instance();
    case 2:
      return ::artm::core::DataLoaderConfig::default_instance();
    case 3:
      return ::artm::core::Void::default_instance();
    case 4:
      return ::artm::core::CreateOrReconfigureModelArgs::default_instance();
    case 5:
      return ::artm::core::DisposeModelArgs::default_instance();
    case 6:
      return ::artm::core::CreateOrReconfigureRegularizerArgs::default_instance();
    case 7:
      return ::artm::core::DisposeRegularizerArgs::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& NodeControllerService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::core::Void::default_instance();
    case 1:
      return ::artm::core::Void::default_instance();
    case 2:
      return ::artm::core::Void::default_instance();
    case 3:
      return ::artm::core::Void::default_instance();
    case 4:
      return ::artm::core::Void::default_instance();
    case 5:
      return ::artm::core::Void::default_instance();
    case 6:
      return ::artm::core::Void::default_instance();
    case 7:
      return ::artm::core::Void::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

NodeControllerService_Stub::NodeControllerService_Stub(::rpcz::rpc_channel* channel,
                                   const ::std::string& service_name,
                                   bool owns_channel)
  : channel_(channel), service_name_(service_name),
    owns_channel_(owns_channel) {}
NodeControllerService_Stub::NodeControllerService_Stub(::rpcz::rpc_channel* channel,
                                   bool owns_channel)
  : channel_(channel), service_name_(NodeControllerService::descriptor()->name()),
    owns_channel_(owns_channel) {}
NodeControllerService_Stub::~NodeControllerService_Stub() {
  if (owns_channel_) delete channel_;
}

void NodeControllerService_Stub::CreateOrReconfigureInstance(const ::artm::core::InstanceConfig& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(0),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureInstance(const ::artm::core::InstanceConfig& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(0),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeInstance(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(1),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeInstance(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(1),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::CreateOrReconfigureDataLoader(const ::artm::core::DataLoaderConfig& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(2),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureDataLoader(const ::artm::core::DataLoaderConfig& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(2),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeDataLoader(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(3),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeDataLoader(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(3),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::CreateOrReconfigureModel(const ::artm::core::CreateOrReconfigureModelArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(4),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureModel(const ::artm::core::CreateOrReconfigureModelArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(4),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeModel(const ::artm::core::DisposeModelArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(5),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeModel(const ::artm::core::DisposeModelArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(5),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::CreateOrReconfigureRegularizer(const ::artm::core::CreateOrReconfigureRegularizerArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(6),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureRegularizer(const ::artm::core::CreateOrReconfigureRegularizerArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(6),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeRegularizer(const ::artm::core::DisposeRegularizerArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(7),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeRegularizer(const ::artm::core::DisposeRegularizerArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(7),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}

}  // namespace core
}  // namespace artm
