// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: memcached_service.proto

#ifndef RPCZ_memcached_5fservice_2eproto__INCLUDED
#define RPCZ_memcached_5fservice_2eproto__INCLUDED

#include <string>
#include <rpcz/service.hpp>

namespace google {
namespace protobuf {
class ServiceDescriptor;
class MethodDescriptor;
}  // namespace protobuf
}  // namespace google
namespace rpcz {
class rpc;
class closure;
class rpc_channel;
}  //namesacpe rpcz
#include "messages.pb.h"
#include "internals.pb.h"
#include "memcached_service.pb.h"

namespace artm {
namespace memcached {
void rpcz_protobuf_AssignDesc_memcached_5fservice_2eproto();
void rpcz_protobuf_ShutdownFile_memcached_5fservice_2eproto();

class MemcachedService_Stub;

class MemcachedService : public rpcz::service {
 protected:
  // This class should be treated as an abstract interface.
  inline MemcachedService() {};
 public:
  virtual ~MemcachedService();

  typedef MemcachedService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void UpdateModel(const ::artm::core::ModelIncrement& request,
                       ::rpcz::reply< ::artm::TopicModel> response);
  virtual void RetrieveModel(const ::artm::memcached::ModelId& request,
                       ::rpcz::reply< ::artm::TopicModel> response);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void call_method(const ::google::protobuf::MethodDescriptor* method,
                  const ::google::protobuf::Message& request,
                  ::rpcz::server_channel* channel);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MemcachedService);
};

class MemcachedService_Stub {
 public:
  MemcachedService_Stub(::rpcz::rpc_channel* channel, 
                   bool owns_channel=false);
  MemcachedService_Stub(::rpcz::rpc_channel* channel, 
                   const ::std::string& service_name,
                   bool owns_channel=false);
  ~MemcachedService_Stub();

  inline ::rpcz::rpc_channel* channel() { return channel_; }


  void UpdateModel(const ::artm::core::ModelIncrement& request,
                       ::artm::TopicModel* response,
                       ::rpcz::rpc* rpc,                     ::rpcz::closure* done);
  void UpdateModel(const ::artm::core::ModelIncrement& request,
                       ::artm::TopicModel* response,
                       long deadline_ms = -1);
  void RetrieveModel(const ::artm::memcached::ModelId& request,
                       ::artm::TopicModel* response,
                       ::rpcz::rpc* rpc,                     ::rpcz::closure* done);
  void RetrieveModel(const ::artm::memcached::ModelId& request,
                       ::artm::TopicModel* response,
                       long deadline_ms = -1);
 private:
  ::rpcz::rpc_channel* channel_;
  ::std::string service_name_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MemcachedService_Stub);
};

class BatchManagerService_Stub;

class BatchManagerService : public rpcz::service {
 protected:
  // This class should be treated as an abstract interface.
  inline BatchManagerService() {};
 public:
  virtual ~BatchManagerService();

  typedef BatchManagerService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void Schedule(const ::artm::memcached::BatchIds& request,
                       ::rpcz::reply< ::artm::memcached::Void> response);
  virtual void Next(const ::artm::memcached::Void& request,
                       ::rpcz::reply< ::artm::memcached::BatchIds> response);
  virtual void Done(const ::artm::memcached::BatchIds& request,
                       ::rpcz::reply< ::artm::memcached::Void> response);
  virtual void IsEverythingProcessed(const ::artm::memcached::Void& request,
                       ::rpcz::reply< ::artm::memcached::Bool> response);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void call_method(const ::google::protobuf::MethodDescriptor* method,
                  const ::google::protobuf::Message& request,
                  ::rpcz::server_channel* channel);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(BatchManagerService);
};

class BatchManagerService_Stub {
 public:
  BatchManagerService_Stub(::rpcz::rpc_channel* channel, 
                   bool owns_channel=false);
  BatchManagerService_Stub(::rpcz::rpc_channel* channel, 
                   const ::std::string& service_name,
                   bool owns_channel=false);
  ~BatchManagerService_Stub();

  inline ::rpcz::rpc_channel* channel() { return channel_; }


  void Schedule(const ::artm::memcached::BatchIds& request,
                       ::artm::memcached::Void* response,
                       ::rpcz::rpc* rpc,                     ::rpcz::closure* done);
  void Schedule(const ::artm::memcached::BatchIds& request,
                       ::artm::memcached::Void* response,
                       long deadline_ms = -1);
  void Next(const ::artm::memcached::Void& request,
                       ::artm::memcached::BatchIds* response,
                       ::rpcz::rpc* rpc,                     ::rpcz::closure* done);
  void Next(const ::artm::memcached::Void& request,
                       ::artm::memcached::BatchIds* response,
                       long deadline_ms = -1);
  void Done(const ::artm::memcached::BatchIds& request,
                       ::artm::memcached::Void* response,
                       ::rpcz::rpc* rpc,                     ::rpcz::closure* done);
  void Done(const ::artm::memcached::BatchIds& request,
                       ::artm::memcached::Void* response,
                       long deadline_ms = -1);
  void IsEverythingProcessed(const ::artm::memcached::Void& request,
                       ::artm::memcached::Bool* response,
                       ::rpcz::rpc* rpc,                     ::rpcz::closure* done);
  void IsEverythingProcessed(const ::artm::memcached::Void& request,
                       ::artm::memcached::Bool* response,
                       long deadline_ms = -1);
 private:
  ::rpcz::rpc_channel* channel_;
  ::std::string service_name_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(BatchManagerService_Stub);
};


}  // namespace memcached
}  // namespace artm
#endif  // RPCZ_memcached_5fservice_2eproto__INCLUDED
