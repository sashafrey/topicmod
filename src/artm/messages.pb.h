// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace artm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Item;
class Field;
class Batch;
class DataLoaderConfig;
class Stream;
class InstanceConfig;
class ModelConfig;
class RegularizerConfig;
class DirichletThetaConfig;
class DirichletPhiConfig;
class SmoothSparseThetaConfig;
class SmoothSparsePhiConfig;
class DoubleArray;
class Score;
class LoggerConfig;
class ModelTopics;
class TokenTopics;
class ItemTopics;
class BatchTopics;

enum Stream_Type {
  Stream_Type_Global = 0,
  Stream_Type_ItemIdModulus = 1,
  Stream_Type_ItemHashModulus = 3
};
bool Stream_Type_IsValid(int value);
const Stream_Type Stream_Type_Type_MIN = Stream_Type_Global;
const Stream_Type Stream_Type_Type_MAX = Stream_Type_ItemHashModulus;
const int Stream_Type_Type_ARRAYSIZE = Stream_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Stream_Type_descriptor();
inline const ::std::string& Stream_Type_Name(Stream_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Stream_Type_descriptor(), value);
}
inline bool Stream_Type_Parse(
    const ::std::string& name, Stream_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Stream_Type>(
    Stream_Type_descriptor(), name, value);
}
enum RegularizerConfig_Type {
  RegularizerConfig_Type_DirichletTheta = 0,
  RegularizerConfig_Type_DirichletPhi = 1,
  RegularizerConfig_Type_SmoothSparseTheta = 2,
  RegularizerConfig_Type_SmoothSparsePhi = 3
};
bool RegularizerConfig_Type_IsValid(int value);
const RegularizerConfig_Type RegularizerConfig_Type_Type_MIN = RegularizerConfig_Type_DirichletTheta;
const RegularizerConfig_Type RegularizerConfig_Type_Type_MAX = RegularizerConfig_Type_SmoothSparsePhi;
const int RegularizerConfig_Type_Type_ARRAYSIZE = RegularizerConfig_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegularizerConfig_Type_descriptor();
inline const ::std::string& RegularizerConfig_Type_Name(RegularizerConfig_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegularizerConfig_Type_descriptor(), value);
}
inline bool RegularizerConfig_Type_Parse(
    const ::std::string& name, RegularizerConfig_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegularizerConfig_Type>(
    RegularizerConfig_Type_descriptor(), name, value);
}
enum Score_Type {
  Score_Type_Perplexity = 0
};
bool Score_Type_IsValid(int value);
const Score_Type Score_Type_Type_MIN = Score_Type_Perplexity;
const Score_Type Score_Type_Type_MAX = Score_Type_Perplexity;
const int Score_Type_Type_ARRAYSIZE = Score_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Score_Type_descriptor();
inline const ::std::string& Score_Type_Name(Score_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Score_Type_descriptor(), value);
}
inline bool Score_Type_Parse(
    const ::std::string& name, Score_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Score_Type>(
    Score_Type_descriptor(), name, value);
}
enum LoggerConfig_Level {
  LoggerConfig_Level_DISABLED = 0,
  LoggerConfig_Level_ERROR = 1,
  LoggerConfig_Level_WARNING = 2,
  LoggerConfig_Level_INFO = 3,
  LoggerConfig_Level_VERBOSE = 4
};
bool LoggerConfig_Level_IsValid(int value);
const LoggerConfig_Level LoggerConfig_Level_Level_MIN = LoggerConfig_Level_DISABLED;
const LoggerConfig_Level LoggerConfig_Level_Level_MAX = LoggerConfig_Level_VERBOSE;
const int LoggerConfig_Level_Level_ARRAYSIZE = LoggerConfig_Level_Level_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoggerConfig_Level_descriptor();
inline const ::std::string& LoggerConfig_Level_Name(LoggerConfig_Level value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoggerConfig_Level_descriptor(), value);
}
inline bool LoggerConfig_Level_Parse(
    const ::std::string& name, LoggerConfig_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoggerConfig_Level>(
    LoggerConfig_Level_descriptor(), name, value);
}
// ===================================================================

class Item : public ::google::protobuf::Message {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .artm.Field field = 2;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 2;
  inline const ::artm::Field& field(int index) const;
  inline ::artm::Field* mutable_field(int index);
  inline ::artm::Field* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Field >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Field >*
      mutable_field();

  // @@protoc_insertion_point(class_scope:artm.Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::Field > field_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string field_name = 1 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // repeated int32 token_id = 2;
  inline int token_id_size() const;
  inline void clear_token_id();
  static const int kTokenIdFieldNumber = 2;
  inline ::google::protobuf::int32 token_id(int index) const;
  inline void set_token_id(int index, ::google::protobuf::int32 value);
  inline void add_token_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_id();

  // repeated int32 token_count = 3;
  inline int token_count_size() const;
  inline void clear_token_count();
  static const int kTokenCountFieldNumber = 3;
  inline ::google::protobuf::int32 token_count(int index) const;
  inline void set_token_count(int index, ::google::protobuf::int32 value);
  inline void add_token_count(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_count() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_count();

  // @@protoc_insertion_point(class_scope:artm.Field)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class Batch : public ::google::protobuf::Message {
 public:
  Batch();
  virtual ~Batch();

  Batch(const Batch& from);

  inline Batch& operator=(const Batch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Batch& default_instance();

  void Swap(Batch* other);

  // implements Message ----------------------------------------------

  Batch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Batch& from);
  void MergeFrom(const Batch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string token = 1;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated .artm.Item item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::artm::Item& item(int index) const;
  inline ::artm::Item* mutable_item(int index);
  inline ::artm::Item* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Item >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Item >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:artm.Batch)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::artm::Item > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Batch* default_instance_;
};
// -------------------------------------------------------------------

class DataLoaderConfig : public ::google::protobuf::Message {
 public:
  DataLoaderConfig();
  virtual ~DataLoaderConfig();

  DataLoaderConfig(const DataLoaderConfig& from);

  inline DataLoaderConfig& operator=(const DataLoaderConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataLoaderConfig& default_instance();

  void Swap(DataLoaderConfig* other);

  // implements Message ----------------------------------------------

  DataLoaderConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataLoaderConfig& from);
  void MergeFrom(const DataLoaderConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 instance_id = 1;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  inline ::google::protobuf::int32 instance_id() const;
  inline void set_instance_id(::google::protobuf::int32 value);

  // optional string disk_path = 2;
  inline bool has_disk_path() const;
  inline void clear_disk_path();
  static const int kDiskPathFieldNumber = 2;
  inline const ::std::string& disk_path() const;
  inline void set_disk_path(const ::std::string& value);
  inline void set_disk_path(const char* value);
  inline void set_disk_path(const char* value, size_t size);
  inline ::std::string* mutable_disk_path();
  inline ::std::string* release_disk_path();
  inline void set_allocated_disk_path(::std::string* disk_path);

  // optional int32 queue_size = 3 [default = 10];
  inline bool has_queue_size() const;
  inline void clear_queue_size();
  static const int kQueueSizeFieldNumber = 3;
  inline ::google::protobuf::int32 queue_size() const;
  inline void set_queue_size(::google::protobuf::int32 value);

  // repeated .artm.Stream stream = 4;
  inline int stream_size() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 4;
  inline const ::artm::Stream& stream(int index) const;
  inline ::artm::Stream* mutable_stream(int index);
  inline ::artm::Stream* add_stream();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Stream >&
      stream() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Stream >*
      mutable_stream();

  // @@protoc_insertion_point(class_scope:artm.DataLoaderConfig)
 private:
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_disk_path();
  inline void clear_has_disk_path();
  inline void set_has_queue_size();
  inline void clear_has_queue_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* disk_path_;
  ::google::protobuf::int32 instance_id_;
  ::google::protobuf::int32 queue_size_;
  ::google::protobuf::RepeatedPtrField< ::artm::Stream > stream_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DataLoaderConfig* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  void Swap(Stream* other);

  // implements Message ----------------------------------------------

  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Stream_Type Type;
  static const Type Global = Stream_Type_Global;
  static const Type ItemIdModulus = Stream_Type_ItemIdModulus;
  static const Type ItemHashModulus = Stream_Type_ItemHashModulus;
  static inline bool Type_IsValid(int value) {
    return Stream_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Stream_Type_Type_MIN;
  static const Type Type_MAX =
    Stream_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Stream_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Stream_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Stream_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Stream_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .artm.Stream.Type type = 1 [default = Global];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::artm::Stream_Type type() const;
  inline void set_type(::artm::Stream_Type value);

  // optional string name = 2 [default = "@global"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 modulus = 3;
  inline bool has_modulus() const;
  inline void clear_modulus();
  static const int kModulusFieldNumber = 3;
  inline ::google::protobuf::int32 modulus() const;
  inline void set_modulus(::google::protobuf::int32 value);

  // repeated int32 residuals = 4;
  inline int residuals_size() const;
  inline void clear_residuals();
  static const int kResidualsFieldNumber = 4;
  inline ::google::protobuf::int32 residuals(int index) const;
  inline void set_residuals(int index, ::google::protobuf::int32 value);
  inline void add_residuals(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      residuals() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_residuals();

  // @@protoc_insertion_point(class_scope:artm.Stream)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_modulus();
  inline void clear_has_modulus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  int type_;
  ::google::protobuf::int32 modulus_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > residuals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class InstanceConfig : public ::google::protobuf::Message {
 public:
  InstanceConfig();
  virtual ~InstanceConfig();

  InstanceConfig(const InstanceConfig& from);

  inline InstanceConfig& operator=(const InstanceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceConfig& default_instance();

  void Swap(InstanceConfig* other);

  // implements Message ----------------------------------------------

  InstanceConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceConfig& from);
  void MergeFrom(const InstanceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 processors_count = 1 [default = 1];
  inline bool has_processors_count() const;
  inline void clear_processors_count();
  static const int kProcessorsCountFieldNumber = 1;
  inline ::google::protobuf::int32 processors_count() const;
  inline void set_processors_count(::google::protobuf::int32 value);

  // optional string memcached_endpoint = 2;
  inline bool has_memcached_endpoint() const;
  inline void clear_memcached_endpoint();
  static const int kMemcachedEndpointFieldNumber = 2;
  inline const ::std::string& memcached_endpoint() const;
  inline void set_memcached_endpoint(const ::std::string& value);
  inline void set_memcached_endpoint(const char* value);
  inline void set_memcached_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_memcached_endpoint();
  inline ::std::string* release_memcached_endpoint();
  inline void set_allocated_memcached_endpoint(::std::string* memcached_endpoint);

  // @@protoc_insertion_point(class_scope:artm.InstanceConfig)
 private:
  inline void set_has_processors_count();
  inline void clear_has_processors_count();
  inline void set_has_memcached_endpoint();
  inline void clear_has_memcached_endpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* memcached_endpoint_;
  ::google::protobuf::int32 processors_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static InstanceConfig* default_instance_;
};
// -------------------------------------------------------------------

class ModelConfig : public ::google::protobuf::Message {
 public:
  ModelConfig();
  virtual ~ModelConfig();

  ModelConfig(const ModelConfig& from);

  inline ModelConfig& operator=(const ModelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelConfig& default_instance();

  void Swap(ModelConfig* other);

  // implements Message ----------------------------------------------

  ModelConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelConfig& from);
  void MergeFrom(const ModelConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 topics_count = 2 [default = 32];
  inline bool has_topics_count() const;
  inline void clear_topics_count();
  static const int kTopicsCountFieldNumber = 2;
  inline ::google::protobuf::int32 topics_count() const;
  inline void set_topics_count(::google::protobuf::int32 value);

  // optional bool enabled = 3 [default = false];
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional int32 inner_iterations_count = 4 [default = 10];
  inline bool has_inner_iterations_count() const;
  inline void clear_inner_iterations_count();
  static const int kInnerIterationsCountFieldNumber = 4;
  inline ::google::protobuf::int32 inner_iterations_count() const;
  inline void set_inner_iterations_count(::google::protobuf::int32 value);

  // optional string field_name = 5 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 5;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 6 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 6;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // repeated .artm.Score score = 7;
  inline int score_size() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 7;
  inline const ::artm::Score& score(int index) const;
  inline ::artm::Score* mutable_score(int index);
  inline ::artm::Score* add_score();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Score >&
      score() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Score >*
      mutable_score();

  // optional bool reuse_theta = 8 [default = false];
  inline bool has_reuse_theta() const;
  inline void clear_reuse_theta();
  static const int kReuseThetaFieldNumber = 8;
  inline bool reuse_theta() const;
  inline void set_reuse_theta(bool value);

  // optional bool cache_token_counters = 9 [default = false];
  inline bool has_cache_token_counters() const;
  inline void clear_cache_token_counters();
  static const int kCacheTokenCountersFieldNumber = 9;
  inline bool cache_token_counters() const;
  inline void set_cache_token_counters(bool value);

  // repeated string regularizer_name = 10;
  inline int regularizer_name_size() const;
  inline void clear_regularizer_name();
  static const int kRegularizerNameFieldNumber = 10;
  inline const ::std::string& regularizer_name(int index) const;
  inline ::std::string* mutable_regularizer_name(int index);
  inline void set_regularizer_name(int index, const ::std::string& value);
  inline void set_regularizer_name(int index, const char* value);
  inline void set_regularizer_name(int index, const char* value, size_t size);
  inline ::std::string* add_regularizer_name();
  inline void add_regularizer_name(const ::std::string& value);
  inline void add_regularizer_name(const char* value);
  inline void add_regularizer_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& regularizer_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_regularizer_name();

  // @@protoc_insertion_point(class_scope:artm.ModelConfig)
 private:
  inline void set_has_topics_count();
  inline void clear_has_topics_count();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_inner_iterations_count();
  inline void clear_has_inner_iterations_count();
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();
  inline void set_has_reuse_theta();
  inline void clear_has_reuse_theta();
  inline void set_has_cache_token_counters();
  inline void clear_has_cache_token_counters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 topics_count_;
  ::google::protobuf::int32 inner_iterations_count_;
  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  ::google::protobuf::RepeatedPtrField< ::artm::Score > score_;
  ::google::protobuf::RepeatedPtrField< ::std::string> regularizer_name_;
  bool enabled_;
  bool reuse_theta_;
  bool cache_token_counters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ModelConfig* default_instance_;
};
// -------------------------------------------------------------------

class RegularizerConfig : public ::google::protobuf::Message {
 public:
  RegularizerConfig();
  virtual ~RegularizerConfig();

  RegularizerConfig(const RegularizerConfig& from);

  inline RegularizerConfig& operator=(const RegularizerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegularizerConfig& default_instance();

  void Swap(RegularizerConfig* other);

  // implements Message ----------------------------------------------

  RegularizerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegularizerConfig& from);
  void MergeFrom(const RegularizerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegularizerConfig_Type Type;
  static const Type DirichletTheta = RegularizerConfig_Type_DirichletTheta;
  static const Type DirichletPhi = RegularizerConfig_Type_DirichletPhi;
  static const Type SmoothSparseTheta = RegularizerConfig_Type_SmoothSparseTheta;
  static const Type SmoothSparsePhi = RegularizerConfig_Type_SmoothSparsePhi;
  static inline bool Type_IsValid(int value) {
    return RegularizerConfig_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RegularizerConfig_Type_Type_MIN;
  static const Type Type_MAX =
    RegularizerConfig_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RegularizerConfig_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RegularizerConfig_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RegularizerConfig_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RegularizerConfig_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .artm.RegularizerConfig.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::RegularizerConfig_Type type() const;
  inline void set_type(::artm::RegularizerConfig_Type value);

  // required bytes config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const void* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:artm.RegularizerConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* config_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static RegularizerConfig* default_instance_;
};
// -------------------------------------------------------------------

class DirichletThetaConfig : public ::google::protobuf::Message {
 public:
  DirichletThetaConfig();
  virtual ~DirichletThetaConfig();

  DirichletThetaConfig(const DirichletThetaConfig& from);

  inline DirichletThetaConfig& operator=(const DirichletThetaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirichletThetaConfig& default_instance();

  void Swap(DirichletThetaConfig* other);

  // implements Message ----------------------------------------------

  DirichletThetaConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirichletThetaConfig& from);
  void MergeFrom(const DirichletThetaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double alpha_0 = 1;
  inline int alpha_0_size() const;
  inline void clear_alpha_0();
  static const int kAlpha0FieldNumber = 1;
  inline double alpha_0(int index) const;
  inline void set_alpha_0(int index, double value);
  inline void add_alpha_0(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      alpha_0() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_alpha_0();

  // repeated .artm.DoubleArray tilde_alpha = 2;
  inline int tilde_alpha_size() const;
  inline void clear_tilde_alpha();
  static const int kTildeAlphaFieldNumber = 2;
  inline const ::artm::DoubleArray& tilde_alpha(int index) const;
  inline ::artm::DoubleArray* mutable_tilde_alpha(int index);
  inline ::artm::DoubleArray* add_tilde_alpha();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
      tilde_alpha() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
      mutable_tilde_alpha();

  // @@protoc_insertion_point(class_scope:artm.DirichletThetaConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > alpha_0_;
  ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray > tilde_alpha_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DirichletThetaConfig* default_instance_;
};
// -------------------------------------------------------------------

class DirichletPhiConfig : public ::google::protobuf::Message {
 public:
  DirichletPhiConfig();
  virtual ~DirichletPhiConfig();

  DirichletPhiConfig(const DirichletPhiConfig& from);

  inline DirichletPhiConfig& operator=(const DirichletPhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirichletPhiConfig& default_instance();

  void Swap(DirichletPhiConfig* other);

  // implements Message ----------------------------------------------

  DirichletPhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirichletPhiConfig& from);
  void MergeFrom(const DirichletPhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double beta_0 = 1;
  inline bool has_beta_0() const;
  inline void clear_beta_0();
  static const int kBeta0FieldNumber = 1;
  inline double beta_0() const;
  inline void set_beta_0(double value);

  // required .artm.DoubleArray tilde_beta = 2;
  inline bool has_tilde_beta() const;
  inline void clear_tilde_beta();
  static const int kTildeBetaFieldNumber = 2;
  inline const ::artm::DoubleArray& tilde_beta() const;
  inline ::artm::DoubleArray* mutable_tilde_beta();
  inline ::artm::DoubleArray* release_tilde_beta();
  inline void set_allocated_tilde_beta(::artm::DoubleArray* tilde_beta);

  // @@protoc_insertion_point(class_scope:artm.DirichletPhiConfig)
 private:
  inline void set_has_beta_0();
  inline void clear_has_beta_0();
  inline void set_has_tilde_beta();
  inline void clear_has_tilde_beta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double beta_0_;
  ::artm::DoubleArray* tilde_beta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DirichletPhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class SmoothSparseThetaConfig : public ::google::protobuf::Message {
 public:
  SmoothSparseThetaConfig();
  virtual ~SmoothSparseThetaConfig();

  SmoothSparseThetaConfig(const SmoothSparseThetaConfig& from);

  inline SmoothSparseThetaConfig& operator=(const SmoothSparseThetaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmoothSparseThetaConfig& default_instance();

  void Swap(SmoothSparseThetaConfig* other);

  // implements Message ----------------------------------------------

  SmoothSparseThetaConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmoothSparseThetaConfig& from);
  void MergeFrom(const SmoothSparseThetaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 background_topics_count = 1;
  inline bool has_background_topics_count() const;
  inline void clear_background_topics_count();
  static const int kBackgroundTopicsCountFieldNumber = 1;
  inline ::google::protobuf::int32 background_topics_count() const;
  inline void set_background_topics_count(::google::protobuf::int32 value);

  // repeated double alpha_0 = 2;
  inline int alpha_0_size() const;
  inline void clear_alpha_0();
  static const int kAlpha0FieldNumber = 2;
  inline double alpha_0(int index) const;
  inline void set_alpha_0(int index, double value);
  inline void add_alpha_0(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      alpha_0() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_alpha_0();

  // repeated .artm.DoubleArray tilde_alpha = 3;
  inline int tilde_alpha_size() const;
  inline void clear_tilde_alpha();
  static const int kTildeAlphaFieldNumber = 3;
  inline const ::artm::DoubleArray& tilde_alpha(int index) const;
  inline ::artm::DoubleArray* mutable_tilde_alpha(int index);
  inline ::artm::DoubleArray* add_tilde_alpha();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
      tilde_alpha() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
      mutable_tilde_alpha();

  // repeated double background_alpha_0 = 4;
  inline int background_alpha_0_size() const;
  inline void clear_background_alpha_0();
  static const int kBackgroundAlpha0FieldNumber = 4;
  inline double background_alpha_0(int index) const;
  inline void set_background_alpha_0(int index, double value);
  inline void add_background_alpha_0(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      background_alpha_0() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_background_alpha_0();

  // repeated .artm.DoubleArray background_tilde_alpha = 5;
  inline int background_tilde_alpha_size() const;
  inline void clear_background_tilde_alpha();
  static const int kBackgroundTildeAlphaFieldNumber = 5;
  inline const ::artm::DoubleArray& background_tilde_alpha(int index) const;
  inline ::artm::DoubleArray* mutable_background_tilde_alpha(int index);
  inline ::artm::DoubleArray* add_background_tilde_alpha();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
      background_tilde_alpha() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
      mutable_background_tilde_alpha();

  // @@protoc_insertion_point(class_scope:artm.SmoothSparseThetaConfig)
 private:
  inline void set_has_background_topics_count();
  inline void clear_has_background_topics_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > alpha_0_;
  ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray > tilde_alpha_;
  ::google::protobuf::RepeatedField< double > background_alpha_0_;
  ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray > background_tilde_alpha_;
  ::google::protobuf::int32 background_topics_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static SmoothSparseThetaConfig* default_instance_;
};
// -------------------------------------------------------------------

class SmoothSparsePhiConfig : public ::google::protobuf::Message {
 public:
  SmoothSparsePhiConfig();
  virtual ~SmoothSparsePhiConfig();

  SmoothSparsePhiConfig(const SmoothSparsePhiConfig& from);

  inline SmoothSparsePhiConfig& operator=(const SmoothSparsePhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmoothSparsePhiConfig& default_instance();

  void Swap(SmoothSparsePhiConfig* other);

  // implements Message ----------------------------------------------

  SmoothSparsePhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmoothSparsePhiConfig& from);
  void MergeFrom(const SmoothSparsePhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 background_topics_count = 1;
  inline bool has_background_topics_count() const;
  inline void clear_background_topics_count();
  static const int kBackgroundTopicsCountFieldNumber = 1;
  inline ::google::protobuf::int32 background_topics_count() const;
  inline void set_background_topics_count(::google::protobuf::int32 value);

  // required double beta_0 = 2;
  inline bool has_beta_0() const;
  inline void clear_beta_0();
  static const int kBeta0FieldNumber = 2;
  inline double beta_0() const;
  inline void set_beta_0(double value);

  // required .artm.DoubleArray tilde_beta = 3;
  inline bool has_tilde_beta() const;
  inline void clear_tilde_beta();
  static const int kTildeBetaFieldNumber = 3;
  inline const ::artm::DoubleArray& tilde_beta() const;
  inline ::artm::DoubleArray* mutable_tilde_beta();
  inline ::artm::DoubleArray* release_tilde_beta();
  inline void set_allocated_tilde_beta(::artm::DoubleArray* tilde_beta);

  // repeated double background_beta_0 = 4;
  inline int background_beta_0_size() const;
  inline void clear_background_beta_0();
  static const int kBackgroundBeta0FieldNumber = 4;
  inline double background_beta_0(int index) const;
  inline void set_background_beta_0(int index, double value);
  inline void add_background_beta_0(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      background_beta_0() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_background_beta_0();

  // repeated .artm.DoubleArray background_tilde_beta = 5;
  inline int background_tilde_beta_size() const;
  inline void clear_background_tilde_beta();
  static const int kBackgroundTildeBetaFieldNumber = 5;
  inline const ::artm::DoubleArray& background_tilde_beta(int index) const;
  inline ::artm::DoubleArray* mutable_background_tilde_beta(int index);
  inline ::artm::DoubleArray* add_background_tilde_beta();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
      background_tilde_beta() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
      mutable_background_tilde_beta();

  // @@protoc_insertion_point(class_scope:artm.SmoothSparsePhiConfig)
 private:
  inline void set_has_background_topics_count();
  inline void clear_has_background_topics_count();
  inline void set_has_beta_0();
  inline void clear_has_beta_0();
  inline void set_has_tilde_beta();
  inline void clear_has_tilde_beta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double beta_0_;
  ::artm::DoubleArray* tilde_beta_;
  ::google::protobuf::RepeatedField< double > background_beta_0_;
  ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray > background_tilde_beta_;
  ::google::protobuf::int32 background_topics_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static SmoothSparsePhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class DoubleArray : public ::google::protobuf::Message {
 public:
  DoubleArray();
  virtual ~DoubleArray();

  DoubleArray(const DoubleArray& from);

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleArray& default_instance();

  void Swap(DoubleArray* other);

  // implements Message ----------------------------------------------

  DoubleArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoubleArray& from);
  void MergeFrom(const DoubleArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.DoubleArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DoubleArray* default_instance_;
};
// -------------------------------------------------------------------

class Score : public ::google::protobuf::Message {
 public:
  Score();
  virtual ~Score();

  Score(const Score& from);

  inline Score& operator=(const Score& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Score& default_instance();

  void Swap(Score* other);

  // implements Message ----------------------------------------------

  Score* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Score& from);
  void MergeFrom(const Score& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Score_Type Type;
  static const Type Perplexity = Score_Type_Perplexity;
  static inline bool Type_IsValid(int value) {
    return Score_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Score_Type_Type_MIN;
  static const Type Type_MAX =
    Score_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Score_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Score_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Score_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Score_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .artm.Score.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::artm::Score_Type type() const;
  inline void set_type(::artm::Score_Type value);

  // optional string field_name = 2 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 2;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 3 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 3;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // @@protoc_insertion_point(class_scope:artm.Score)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Score* default_instance_;
};
// -------------------------------------------------------------------

class LoggerConfig : public ::google::protobuf::Message {
 public:
  LoggerConfig();
  virtual ~LoggerConfig();

  LoggerConfig(const LoggerConfig& from);

  inline LoggerConfig& operator=(const LoggerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggerConfig& default_instance();

  void Swap(LoggerConfig* other);

  // implements Message ----------------------------------------------

  LoggerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoggerConfig& from);
  void MergeFrom(const LoggerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoggerConfig_Level Level;
  static const Level DISABLED = LoggerConfig_Level_DISABLED;
  static const Level ERROR = LoggerConfig_Level_ERROR;
  static const Level WARNING = LoggerConfig_Level_WARNING;
  static const Level INFO = LoggerConfig_Level_INFO;
  static const Level VERBOSE = LoggerConfig_Level_VERBOSE;
  static inline bool Level_IsValid(int value) {
    return LoggerConfig_Level_IsValid(value);
  }
  static const Level Level_MIN =
    LoggerConfig_Level_Level_MIN;
  static const Level Level_MAX =
    LoggerConfig_Level_Level_MAX;
  static const int Level_ARRAYSIZE =
    LoggerConfig_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Level_descriptor() {
    return LoggerConfig_Level_descriptor();
  }
  static inline const ::std::string& Level_Name(Level value) {
    return LoggerConfig_Level_Name(value);
  }
  static inline bool Level_Parse(const ::std::string& name,
      Level* value) {
    return LoggerConfig_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string log_location = 1;
  inline bool has_log_location() const;
  inline void clear_log_location();
  static const int kLogLocationFieldNumber = 1;
  inline const ::std::string& log_location() const;
  inline void set_log_location(const ::std::string& value);
  inline void set_log_location(const char* value);
  inline void set_log_location(const char* value, size_t size);
  inline ::std::string* mutable_log_location();
  inline ::std::string* release_log_location();
  inline void set_allocated_log_location(::std::string* log_location);

  // optional .artm.LoggerConfig.Level level = 2 [default = INFO];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::artm::LoggerConfig_Level level() const;
  inline void set_level(::artm::LoggerConfig_Level value);

  // @@protoc_insertion_point(class_scope:artm.LoggerConfig)
 private:
  inline void set_has_log_location();
  inline void clear_has_log_location();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* log_location_;
  int level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static LoggerConfig* default_instance_;
};
// -------------------------------------------------------------------

class ModelTopics : public ::google::protobuf::Message {
 public:
  ModelTopics();
  virtual ~ModelTopics();

  ModelTopics(const ModelTopics& from);

  inline ModelTopics& operator=(const ModelTopics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelTopics& default_instance();

  void Swap(ModelTopics* other);

  // implements Message ----------------------------------------------

  ModelTopics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelTopics& from);
  void MergeFrom(const ModelTopics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .artm.TokenTopics token_topic = 1;
  inline int token_topic_size() const;
  inline void clear_token_topic();
  static const int kTokenTopicFieldNumber = 1;
  inline const ::artm::TokenTopics& token_topic(int index) const;
  inline ::artm::TokenTopics* mutable_token_topic(int index);
  inline ::artm::TokenTopics* add_token_topic();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::TokenTopics >&
      token_topic() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::TokenTopics >*
      mutable_token_topic();

  // optional int32 items_processed = 2;
  inline bool has_items_processed() const;
  inline void clear_items_processed();
  static const int kItemsProcessedFieldNumber = 2;
  inline ::google::protobuf::int32 items_processed() const;
  inline void set_items_processed(::google::protobuf::int32 value);

  // repeated double score = 3;
  inline int score_size() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline double score(int index) const;
  inline void set_score(int index, double value);
  inline void add_score(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      score() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_score();

  // @@protoc_insertion_point(class_scope:artm.ModelTopics)
 private:
  inline void set_has_items_processed();
  inline void clear_has_items_processed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::TokenTopics > token_topic_;
  ::google::protobuf::RepeatedField< double > score_;
  ::google::protobuf::int32 items_processed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ModelTopics* default_instance_;
};
// -------------------------------------------------------------------

class TokenTopics : public ::google::protobuf::Message {
 public:
  TokenTopics();
  virtual ~TokenTopics();

  TokenTopics(const TokenTopics& from);

  inline TokenTopics& operator=(const TokenTopics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenTopics& default_instance();

  void Swap(TokenTopics* other);

  // implements Message ----------------------------------------------

  TokenTopics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TokenTopics& from);
  void MergeFrom(const TokenTopics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional int32 token_id = 2;
  inline bool has_token_id() const;
  inline void clear_token_id();
  static const int kTokenIdFieldNumber = 2;
  inline ::google::protobuf::int32 token_id() const;
  inline void set_token_id(::google::protobuf::int32 value);

  // repeated float topic_weight = 3;
  inline int topic_weight_size() const;
  inline void clear_topic_weight();
  static const int kTopicWeightFieldNumber = 3;
  inline float topic_weight(int index) const;
  inline void set_topic_weight(int index, float value);
  inline void add_topic_weight(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      topic_weight() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_topic_weight();

  // @@protoc_insertion_point(class_scope:artm.TokenTopics)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_token_id();
  inline void clear_has_token_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::RepeatedField< float > topic_weight_;
  ::google::protobuf::int32 token_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static TokenTopics* default_instance_;
};
// -------------------------------------------------------------------

class ItemTopics : public ::google::protobuf::Message {
 public:
  ItemTopics();
  virtual ~ItemTopics();

  ItemTopics(const ItemTopics& from);

  inline ItemTopics& operator=(const ItemTopics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemTopics& default_instance();

  void Swap(ItemTopics* other);

  // implements Message ----------------------------------------------

  ItemTopics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemTopics& from);
  void MergeFrom(const ItemTopics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated float topic_weight = 2;
  inline int topic_weight_size() const;
  inline void clear_topic_weight();
  static const int kTopicWeightFieldNumber = 2;
  inline float topic_weight(int index) const;
  inline void set_topic_weight(int index, float value);
  inline void add_topic_weight(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      topic_weight() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_topic_weight();

  // @@protoc_insertion_point(class_scope:artm.ItemTopics)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > topic_weight_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ItemTopics* default_instance_;
};
// -------------------------------------------------------------------

class BatchTopics : public ::google::protobuf::Message {
 public:
  BatchTopics();
  virtual ~BatchTopics();

  BatchTopics(const BatchTopics& from);

  inline BatchTopics& operator=(const BatchTopics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchTopics& default_instance();

  void Swap(BatchTopics* other);

  // implements Message ----------------------------------------------

  BatchTopics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchTopics& from);
  void MergeFrom(const BatchTopics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .artm.ItemTopics item_topics = 1;
  inline int item_topics_size() const;
  inline void clear_item_topics();
  static const int kItemTopicsFieldNumber = 1;
  inline const ::artm::ItemTopics& item_topics(int index) const;
  inline ::artm::ItemTopics* mutable_item_topics(int index);
  inline ::artm::ItemTopics* add_item_topics();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::ItemTopics >&
      item_topics() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::ItemTopics >*
      mutable_item_topics();

  // @@protoc_insertion_point(class_scope:artm.BatchTopics)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::ItemTopics > item_topics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static BatchTopics* default_instance_;
};
// ===================================================================


// ===================================================================

// Item

// optional int32 id = 1;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Item::id() const {
  return id_;
}
inline void Item::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .artm.Field field = 2;
inline int Item::field_size() const {
  return field_.size();
}
inline void Item::clear_field() {
  field_.Clear();
}
inline const ::artm::Field& Item::field(int index) const {
  return field_.Get(index);
}
inline ::artm::Field* Item::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::artm::Field* Item::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Field >&
Item::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Field >*
Item::mutable_field() {
  return &field_;
}

// -------------------------------------------------------------------

// Field

// optional string field_name = 1 [default = "@body"];
inline bool Field::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& Field::field_name() const {
  return *field_name_;
}
inline void Field::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void Field::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void Field::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* Field::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void Field::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// repeated int32 token_id = 2;
inline int Field::token_id_size() const {
  return token_id_.size();
}
inline void Field::clear_token_id() {
  token_id_.Clear();
}
inline ::google::protobuf::int32 Field::token_id(int index) const {
  return token_id_.Get(index);
}
inline void Field::set_token_id(int index, ::google::protobuf::int32 value) {
  token_id_.Set(index, value);
}
inline void Field::add_token_id(::google::protobuf::int32 value) {
  token_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Field::token_id() const {
  return token_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Field::mutable_token_id() {
  return &token_id_;
}

// repeated int32 token_count = 3;
inline int Field::token_count_size() const {
  return token_count_.size();
}
inline void Field::clear_token_count() {
  token_count_.Clear();
}
inline ::google::protobuf::int32 Field::token_count(int index) const {
  return token_count_.Get(index);
}
inline void Field::set_token_count(int index, ::google::protobuf::int32 value) {
  token_count_.Set(index, value);
}
inline void Field::add_token_count(::google::protobuf::int32 value) {
  token_count_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Field::token_count() const {
  return token_count_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Field::mutable_token_count() {
  return &token_count_;
}

// -------------------------------------------------------------------

// Batch

// repeated string token = 1;
inline int Batch::token_size() const {
  return token_.size();
}
inline void Batch::clear_token() {
  token_.Clear();
}
inline const ::std::string& Batch::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* Batch::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void Batch::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void Batch::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void Batch::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Batch::add_token() {
  return token_.Add();
}
inline void Batch::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void Batch::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void Batch::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Batch::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Batch::mutable_token() {
  return &token_;
}

// repeated .artm.Item item = 2;
inline int Batch::item_size() const {
  return item_.size();
}
inline void Batch::clear_item() {
  item_.Clear();
}
inline const ::artm::Item& Batch::item(int index) const {
  return item_.Get(index);
}
inline ::artm::Item* Batch::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::artm::Item* Batch::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Item >&
Batch::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Item >*
Batch::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// DataLoaderConfig

// required int32 instance_id = 1;
inline bool DataLoaderConfig::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataLoaderConfig::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataLoaderConfig::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataLoaderConfig::clear_instance_id() {
  instance_id_ = 0;
  clear_has_instance_id();
}
inline ::google::protobuf::int32 DataLoaderConfig::instance_id() const {
  return instance_id_;
}
inline void DataLoaderConfig::set_instance_id(::google::protobuf::int32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// optional string disk_path = 2;
inline bool DataLoaderConfig::has_disk_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataLoaderConfig::set_has_disk_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataLoaderConfig::clear_has_disk_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataLoaderConfig::clear_disk_path() {
  if (disk_path_ != &::google::protobuf::internal::kEmptyString) {
    disk_path_->clear();
  }
  clear_has_disk_path();
}
inline const ::std::string& DataLoaderConfig::disk_path() const {
  return *disk_path_;
}
inline void DataLoaderConfig::set_disk_path(const ::std::string& value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void DataLoaderConfig::set_disk_path(const char* value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void DataLoaderConfig::set_disk_path(const char* value, size_t size) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataLoaderConfig::mutable_disk_path() {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  return disk_path_;
}
inline ::std::string* DataLoaderConfig::release_disk_path() {
  clear_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_path_;
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataLoaderConfig::set_allocated_disk_path(::std::string* disk_path) {
  if (disk_path_ != &::google::protobuf::internal::kEmptyString) {
    delete disk_path_;
  }
  if (disk_path) {
    set_has_disk_path();
    disk_path_ = disk_path;
  } else {
    clear_has_disk_path();
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 queue_size = 3 [default = 10];
inline bool DataLoaderConfig::has_queue_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataLoaderConfig::set_has_queue_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataLoaderConfig::clear_has_queue_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataLoaderConfig::clear_queue_size() {
  queue_size_ = 10;
  clear_has_queue_size();
}
inline ::google::protobuf::int32 DataLoaderConfig::queue_size() const {
  return queue_size_;
}
inline void DataLoaderConfig::set_queue_size(::google::protobuf::int32 value) {
  set_has_queue_size();
  queue_size_ = value;
}

// repeated .artm.Stream stream = 4;
inline int DataLoaderConfig::stream_size() const {
  return stream_.size();
}
inline void DataLoaderConfig::clear_stream() {
  stream_.Clear();
}
inline const ::artm::Stream& DataLoaderConfig::stream(int index) const {
  return stream_.Get(index);
}
inline ::artm::Stream* DataLoaderConfig::mutable_stream(int index) {
  return stream_.Mutable(index);
}
inline ::artm::Stream* DataLoaderConfig::add_stream() {
  return stream_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Stream >&
DataLoaderConfig::stream() const {
  return stream_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Stream >*
DataLoaderConfig::mutable_stream() {
  return &stream_;
}

// -------------------------------------------------------------------

// Stream

// required .artm.Stream.Type type = 1 [default = Global];
inline bool Stream::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::Stream_Type Stream::type() const {
  return static_cast< ::artm::Stream_Type >(type_);
}
inline void Stream::set_type(::artm::Stream_Type value) {
  assert(::artm::Stream_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 2 [default = "@global"];
inline bool Stream::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Stream::name() const {
  return *name_;
}
inline void Stream::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stream::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stream::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stream::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Stream::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Stream::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// optional int32 modulus = 3;
inline bool Stream::has_modulus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stream::set_has_modulus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stream::clear_has_modulus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stream::clear_modulus() {
  modulus_ = 0;
  clear_has_modulus();
}
inline ::google::protobuf::int32 Stream::modulus() const {
  return modulus_;
}
inline void Stream::set_modulus(::google::protobuf::int32 value) {
  set_has_modulus();
  modulus_ = value;
}

// repeated int32 residuals = 4;
inline int Stream::residuals_size() const {
  return residuals_.size();
}
inline void Stream::clear_residuals() {
  residuals_.Clear();
}
inline ::google::protobuf::int32 Stream::residuals(int index) const {
  return residuals_.Get(index);
}
inline void Stream::set_residuals(int index, ::google::protobuf::int32 value) {
  residuals_.Set(index, value);
}
inline void Stream::add_residuals(::google::protobuf::int32 value) {
  residuals_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Stream::residuals() const {
  return residuals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Stream::mutable_residuals() {
  return &residuals_;
}

// -------------------------------------------------------------------

// InstanceConfig

// optional int32 processors_count = 1 [default = 1];
inline bool InstanceConfig::has_processors_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceConfig::set_has_processors_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceConfig::clear_has_processors_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceConfig::clear_processors_count() {
  processors_count_ = 1;
  clear_has_processors_count();
}
inline ::google::protobuf::int32 InstanceConfig::processors_count() const {
  return processors_count_;
}
inline void InstanceConfig::set_processors_count(::google::protobuf::int32 value) {
  set_has_processors_count();
  processors_count_ = value;
}

// optional string memcached_endpoint = 2;
inline bool InstanceConfig::has_memcached_endpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceConfig::set_has_memcached_endpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceConfig::clear_has_memcached_endpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceConfig::clear_memcached_endpoint() {
  if (memcached_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    memcached_endpoint_->clear();
  }
  clear_has_memcached_endpoint();
}
inline const ::std::string& InstanceConfig::memcached_endpoint() const {
  return *memcached_endpoint_;
}
inline void InstanceConfig::set_memcached_endpoint(const ::std::string& value) {
  set_has_memcached_endpoint();
  if (memcached_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    memcached_endpoint_ = new ::std::string;
  }
  memcached_endpoint_->assign(value);
}
inline void InstanceConfig::set_memcached_endpoint(const char* value) {
  set_has_memcached_endpoint();
  if (memcached_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    memcached_endpoint_ = new ::std::string;
  }
  memcached_endpoint_->assign(value);
}
inline void InstanceConfig::set_memcached_endpoint(const char* value, size_t size) {
  set_has_memcached_endpoint();
  if (memcached_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    memcached_endpoint_ = new ::std::string;
  }
  memcached_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstanceConfig::mutable_memcached_endpoint() {
  set_has_memcached_endpoint();
  if (memcached_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    memcached_endpoint_ = new ::std::string;
  }
  return memcached_endpoint_;
}
inline ::std::string* InstanceConfig::release_memcached_endpoint() {
  clear_has_memcached_endpoint();
  if (memcached_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memcached_endpoint_;
    memcached_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstanceConfig::set_allocated_memcached_endpoint(::std::string* memcached_endpoint) {
  if (memcached_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete memcached_endpoint_;
  }
  if (memcached_endpoint) {
    set_has_memcached_endpoint();
    memcached_endpoint_ = memcached_endpoint;
  } else {
    clear_has_memcached_endpoint();
    memcached_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ModelConfig

// optional int32 topics_count = 2 [default = 32];
inline bool ModelConfig::has_topics_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelConfig::set_has_topics_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelConfig::clear_has_topics_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelConfig::clear_topics_count() {
  topics_count_ = 32;
  clear_has_topics_count();
}
inline ::google::protobuf::int32 ModelConfig::topics_count() const {
  return topics_count_;
}
inline void ModelConfig::set_topics_count(::google::protobuf::int32 value) {
  set_has_topics_count();
  topics_count_ = value;
}

// optional bool enabled = 3 [default = false];
inline bool ModelConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool ModelConfig::enabled() const {
  return enabled_;
}
inline void ModelConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional int32 inner_iterations_count = 4 [default = 10];
inline bool ModelConfig::has_inner_iterations_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelConfig::set_has_inner_iterations_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelConfig::clear_has_inner_iterations_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelConfig::clear_inner_iterations_count() {
  inner_iterations_count_ = 10;
  clear_has_inner_iterations_count();
}
inline ::google::protobuf::int32 ModelConfig::inner_iterations_count() const {
  return inner_iterations_count_;
}
inline void ModelConfig::set_inner_iterations_count(::google::protobuf::int32 value) {
  set_has_inner_iterations_count();
  inner_iterations_count_ = value;
}

// optional string field_name = 5 [default = "@body"];
inline bool ModelConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& ModelConfig::field_name() const {
  return *field_name_;
}
inline void ModelConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ModelConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ModelConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* ModelConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 6 [default = "@global"];
inline bool ModelConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& ModelConfig::stream_name() const {
  return *stream_name_;
}
inline void ModelConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ModelConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ModelConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* ModelConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// repeated .artm.Score score = 7;
inline int ModelConfig::score_size() const {
  return score_.size();
}
inline void ModelConfig::clear_score() {
  score_.Clear();
}
inline const ::artm::Score& ModelConfig::score(int index) const {
  return score_.Get(index);
}
inline ::artm::Score* ModelConfig::mutable_score(int index) {
  return score_.Mutable(index);
}
inline ::artm::Score* ModelConfig::add_score() {
  return score_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Score >&
ModelConfig::score() const {
  return score_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Score >*
ModelConfig::mutable_score() {
  return &score_;
}

// optional bool reuse_theta = 8 [default = false];
inline bool ModelConfig::has_reuse_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ModelConfig::set_has_reuse_theta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ModelConfig::clear_has_reuse_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ModelConfig::clear_reuse_theta() {
  reuse_theta_ = false;
  clear_has_reuse_theta();
}
inline bool ModelConfig::reuse_theta() const {
  return reuse_theta_;
}
inline void ModelConfig::set_reuse_theta(bool value) {
  set_has_reuse_theta();
  reuse_theta_ = value;
}

// optional bool cache_token_counters = 9 [default = false];
inline bool ModelConfig::has_cache_token_counters() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ModelConfig::set_has_cache_token_counters() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ModelConfig::clear_has_cache_token_counters() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ModelConfig::clear_cache_token_counters() {
  cache_token_counters_ = false;
  clear_has_cache_token_counters();
}
inline bool ModelConfig::cache_token_counters() const {
  return cache_token_counters_;
}
inline void ModelConfig::set_cache_token_counters(bool value) {
  set_has_cache_token_counters();
  cache_token_counters_ = value;
}

// repeated string regularizer_name = 10;
inline int ModelConfig::regularizer_name_size() const {
  return regularizer_name_.size();
}
inline void ModelConfig::clear_regularizer_name() {
  regularizer_name_.Clear();
}
inline const ::std::string& ModelConfig::regularizer_name(int index) const {
  return regularizer_name_.Get(index);
}
inline ::std::string* ModelConfig::mutable_regularizer_name(int index) {
  return regularizer_name_.Mutable(index);
}
inline void ModelConfig::set_regularizer_name(int index, const ::std::string& value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_regularizer_name(int index, const char* value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_regularizer_name(int index, const char* value, size_t size) {
  regularizer_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::add_regularizer_name() {
  return regularizer_name_.Add();
}
inline void ModelConfig::add_regularizer_name(const ::std::string& value) {
  regularizer_name_.Add()->assign(value);
}
inline void ModelConfig::add_regularizer_name(const char* value) {
  regularizer_name_.Add()->assign(value);
}
inline void ModelConfig::add_regularizer_name(const char* value, size_t size) {
  regularizer_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelConfig::regularizer_name() const {
  return regularizer_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelConfig::mutable_regularizer_name() {
  return &regularizer_name_;
}

// -------------------------------------------------------------------

// RegularizerConfig

// required string name = 1;
inline bool RegularizerConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegularizerConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegularizerConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegularizerConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegularizerConfig::name() const {
  return *name_;
}
inline void RegularizerConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegularizerConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegularizerConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .artm.RegularizerConfig.Type type = 2;
inline bool RegularizerConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegularizerConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegularizerConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegularizerConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::RegularizerConfig_Type RegularizerConfig::type() const {
  return static_cast< ::artm::RegularizerConfig_Type >(type_);
}
inline void RegularizerConfig::set_type(::artm::RegularizerConfig_Type value) {
  assert(::artm::RegularizerConfig_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes config = 3;
inline bool RegularizerConfig::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegularizerConfig::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegularizerConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegularizerConfig::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& RegularizerConfig::config() const {
  return *config_;
}
inline void RegularizerConfig::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void RegularizerConfig::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void RegularizerConfig::set_config(const void* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerConfig::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* RegularizerConfig::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegularizerConfig::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DirichletThetaConfig

// repeated double alpha_0 = 1;
inline int DirichletThetaConfig::alpha_0_size() const {
  return alpha_0_.size();
}
inline void DirichletThetaConfig::clear_alpha_0() {
  alpha_0_.Clear();
}
inline double DirichletThetaConfig::alpha_0(int index) const {
  return alpha_0_.Get(index);
}
inline void DirichletThetaConfig::set_alpha_0(int index, double value) {
  alpha_0_.Set(index, value);
}
inline void DirichletThetaConfig::add_alpha_0(double value) {
  alpha_0_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
DirichletThetaConfig::alpha_0() const {
  return alpha_0_;
}
inline ::google::protobuf::RepeatedField< double >*
DirichletThetaConfig::mutable_alpha_0() {
  return &alpha_0_;
}

// repeated .artm.DoubleArray tilde_alpha = 2;
inline int DirichletThetaConfig::tilde_alpha_size() const {
  return tilde_alpha_.size();
}
inline void DirichletThetaConfig::clear_tilde_alpha() {
  tilde_alpha_.Clear();
}
inline const ::artm::DoubleArray& DirichletThetaConfig::tilde_alpha(int index) const {
  return tilde_alpha_.Get(index);
}
inline ::artm::DoubleArray* DirichletThetaConfig::mutable_tilde_alpha(int index) {
  return tilde_alpha_.Mutable(index);
}
inline ::artm::DoubleArray* DirichletThetaConfig::add_tilde_alpha() {
  return tilde_alpha_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
DirichletThetaConfig::tilde_alpha() const {
  return tilde_alpha_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
DirichletThetaConfig::mutable_tilde_alpha() {
  return &tilde_alpha_;
}

// -------------------------------------------------------------------

// DirichletPhiConfig

// required double beta_0 = 1;
inline bool DirichletPhiConfig::has_beta_0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirichletPhiConfig::set_has_beta_0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirichletPhiConfig::clear_has_beta_0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirichletPhiConfig::clear_beta_0() {
  beta_0_ = 0;
  clear_has_beta_0();
}
inline double DirichletPhiConfig::beta_0() const {
  return beta_0_;
}
inline void DirichletPhiConfig::set_beta_0(double value) {
  set_has_beta_0();
  beta_0_ = value;
}

// required .artm.DoubleArray tilde_beta = 2;
inline bool DirichletPhiConfig::has_tilde_beta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirichletPhiConfig::set_has_tilde_beta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirichletPhiConfig::clear_has_tilde_beta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirichletPhiConfig::clear_tilde_beta() {
  if (tilde_beta_ != NULL) tilde_beta_->::artm::DoubleArray::Clear();
  clear_has_tilde_beta();
}
inline const ::artm::DoubleArray& DirichletPhiConfig::tilde_beta() const {
  return tilde_beta_ != NULL ? *tilde_beta_ : *default_instance_->tilde_beta_;
}
inline ::artm::DoubleArray* DirichletPhiConfig::mutable_tilde_beta() {
  set_has_tilde_beta();
  if (tilde_beta_ == NULL) tilde_beta_ = new ::artm::DoubleArray;
  return tilde_beta_;
}
inline ::artm::DoubleArray* DirichletPhiConfig::release_tilde_beta() {
  clear_has_tilde_beta();
  ::artm::DoubleArray* temp = tilde_beta_;
  tilde_beta_ = NULL;
  return temp;
}
inline void DirichletPhiConfig::set_allocated_tilde_beta(::artm::DoubleArray* tilde_beta) {
  delete tilde_beta_;
  tilde_beta_ = tilde_beta;
  if (tilde_beta) {
    set_has_tilde_beta();
  } else {
    clear_has_tilde_beta();
  }
}

// -------------------------------------------------------------------

// SmoothSparseThetaConfig

// required int32 background_topics_count = 1;
inline bool SmoothSparseThetaConfig::has_background_topics_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmoothSparseThetaConfig::set_has_background_topics_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmoothSparseThetaConfig::clear_has_background_topics_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmoothSparseThetaConfig::clear_background_topics_count() {
  background_topics_count_ = 0;
  clear_has_background_topics_count();
}
inline ::google::protobuf::int32 SmoothSparseThetaConfig::background_topics_count() const {
  return background_topics_count_;
}
inline void SmoothSparseThetaConfig::set_background_topics_count(::google::protobuf::int32 value) {
  set_has_background_topics_count();
  background_topics_count_ = value;
}

// repeated double alpha_0 = 2;
inline int SmoothSparseThetaConfig::alpha_0_size() const {
  return alpha_0_.size();
}
inline void SmoothSparseThetaConfig::clear_alpha_0() {
  alpha_0_.Clear();
}
inline double SmoothSparseThetaConfig::alpha_0(int index) const {
  return alpha_0_.Get(index);
}
inline void SmoothSparseThetaConfig::set_alpha_0(int index, double value) {
  alpha_0_.Set(index, value);
}
inline void SmoothSparseThetaConfig::add_alpha_0(double value) {
  alpha_0_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
SmoothSparseThetaConfig::alpha_0() const {
  return alpha_0_;
}
inline ::google::protobuf::RepeatedField< double >*
SmoothSparseThetaConfig::mutable_alpha_0() {
  return &alpha_0_;
}

// repeated .artm.DoubleArray tilde_alpha = 3;
inline int SmoothSparseThetaConfig::tilde_alpha_size() const {
  return tilde_alpha_.size();
}
inline void SmoothSparseThetaConfig::clear_tilde_alpha() {
  tilde_alpha_.Clear();
}
inline const ::artm::DoubleArray& SmoothSparseThetaConfig::tilde_alpha(int index) const {
  return tilde_alpha_.Get(index);
}
inline ::artm::DoubleArray* SmoothSparseThetaConfig::mutable_tilde_alpha(int index) {
  return tilde_alpha_.Mutable(index);
}
inline ::artm::DoubleArray* SmoothSparseThetaConfig::add_tilde_alpha() {
  return tilde_alpha_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
SmoothSparseThetaConfig::tilde_alpha() const {
  return tilde_alpha_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
SmoothSparseThetaConfig::mutable_tilde_alpha() {
  return &tilde_alpha_;
}

// repeated double background_alpha_0 = 4;
inline int SmoothSparseThetaConfig::background_alpha_0_size() const {
  return background_alpha_0_.size();
}
inline void SmoothSparseThetaConfig::clear_background_alpha_0() {
  background_alpha_0_.Clear();
}
inline double SmoothSparseThetaConfig::background_alpha_0(int index) const {
  return background_alpha_0_.Get(index);
}
inline void SmoothSparseThetaConfig::set_background_alpha_0(int index, double value) {
  background_alpha_0_.Set(index, value);
}
inline void SmoothSparseThetaConfig::add_background_alpha_0(double value) {
  background_alpha_0_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
SmoothSparseThetaConfig::background_alpha_0() const {
  return background_alpha_0_;
}
inline ::google::protobuf::RepeatedField< double >*
SmoothSparseThetaConfig::mutable_background_alpha_0() {
  return &background_alpha_0_;
}

// repeated .artm.DoubleArray background_tilde_alpha = 5;
inline int SmoothSparseThetaConfig::background_tilde_alpha_size() const {
  return background_tilde_alpha_.size();
}
inline void SmoothSparseThetaConfig::clear_background_tilde_alpha() {
  background_tilde_alpha_.Clear();
}
inline const ::artm::DoubleArray& SmoothSparseThetaConfig::background_tilde_alpha(int index) const {
  return background_tilde_alpha_.Get(index);
}
inline ::artm::DoubleArray* SmoothSparseThetaConfig::mutable_background_tilde_alpha(int index) {
  return background_tilde_alpha_.Mutable(index);
}
inline ::artm::DoubleArray* SmoothSparseThetaConfig::add_background_tilde_alpha() {
  return background_tilde_alpha_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
SmoothSparseThetaConfig::background_tilde_alpha() const {
  return background_tilde_alpha_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
SmoothSparseThetaConfig::mutable_background_tilde_alpha() {
  return &background_tilde_alpha_;
}

// -------------------------------------------------------------------

// SmoothSparsePhiConfig

// required int32 background_topics_count = 1;
inline bool SmoothSparsePhiConfig::has_background_topics_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmoothSparsePhiConfig::set_has_background_topics_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmoothSparsePhiConfig::clear_has_background_topics_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmoothSparsePhiConfig::clear_background_topics_count() {
  background_topics_count_ = 0;
  clear_has_background_topics_count();
}
inline ::google::protobuf::int32 SmoothSparsePhiConfig::background_topics_count() const {
  return background_topics_count_;
}
inline void SmoothSparsePhiConfig::set_background_topics_count(::google::protobuf::int32 value) {
  set_has_background_topics_count();
  background_topics_count_ = value;
}

// required double beta_0 = 2;
inline bool SmoothSparsePhiConfig::has_beta_0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmoothSparsePhiConfig::set_has_beta_0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmoothSparsePhiConfig::clear_has_beta_0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmoothSparsePhiConfig::clear_beta_0() {
  beta_0_ = 0;
  clear_has_beta_0();
}
inline double SmoothSparsePhiConfig::beta_0() const {
  return beta_0_;
}
inline void SmoothSparsePhiConfig::set_beta_0(double value) {
  set_has_beta_0();
  beta_0_ = value;
}

// required .artm.DoubleArray tilde_beta = 3;
inline bool SmoothSparsePhiConfig::has_tilde_beta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmoothSparsePhiConfig::set_has_tilde_beta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmoothSparsePhiConfig::clear_has_tilde_beta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmoothSparsePhiConfig::clear_tilde_beta() {
  if (tilde_beta_ != NULL) tilde_beta_->::artm::DoubleArray::Clear();
  clear_has_tilde_beta();
}
inline const ::artm::DoubleArray& SmoothSparsePhiConfig::tilde_beta() const {
  return tilde_beta_ != NULL ? *tilde_beta_ : *default_instance_->tilde_beta_;
}
inline ::artm::DoubleArray* SmoothSparsePhiConfig::mutable_tilde_beta() {
  set_has_tilde_beta();
  if (tilde_beta_ == NULL) tilde_beta_ = new ::artm::DoubleArray;
  return tilde_beta_;
}
inline ::artm::DoubleArray* SmoothSparsePhiConfig::release_tilde_beta() {
  clear_has_tilde_beta();
  ::artm::DoubleArray* temp = tilde_beta_;
  tilde_beta_ = NULL;
  return temp;
}
inline void SmoothSparsePhiConfig::set_allocated_tilde_beta(::artm::DoubleArray* tilde_beta) {
  delete tilde_beta_;
  tilde_beta_ = tilde_beta;
  if (tilde_beta) {
    set_has_tilde_beta();
  } else {
    clear_has_tilde_beta();
  }
}

// repeated double background_beta_0 = 4;
inline int SmoothSparsePhiConfig::background_beta_0_size() const {
  return background_beta_0_.size();
}
inline void SmoothSparsePhiConfig::clear_background_beta_0() {
  background_beta_0_.Clear();
}
inline double SmoothSparsePhiConfig::background_beta_0(int index) const {
  return background_beta_0_.Get(index);
}
inline void SmoothSparsePhiConfig::set_background_beta_0(int index, double value) {
  background_beta_0_.Set(index, value);
}
inline void SmoothSparsePhiConfig::add_background_beta_0(double value) {
  background_beta_0_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
SmoothSparsePhiConfig::background_beta_0() const {
  return background_beta_0_;
}
inline ::google::protobuf::RepeatedField< double >*
SmoothSparsePhiConfig::mutable_background_beta_0() {
  return &background_beta_0_;
}

// repeated .artm.DoubleArray background_tilde_beta = 5;
inline int SmoothSparsePhiConfig::background_tilde_beta_size() const {
  return background_tilde_beta_.size();
}
inline void SmoothSparsePhiConfig::clear_background_tilde_beta() {
  background_tilde_beta_.Clear();
}
inline const ::artm::DoubleArray& SmoothSparsePhiConfig::background_tilde_beta(int index) const {
  return background_tilde_beta_.Get(index);
}
inline ::artm::DoubleArray* SmoothSparsePhiConfig::mutable_background_tilde_beta(int index) {
  return background_tilde_beta_.Mutable(index);
}
inline ::artm::DoubleArray* SmoothSparsePhiConfig::add_background_tilde_beta() {
  return background_tilde_beta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
SmoothSparsePhiConfig::background_tilde_beta() const {
  return background_tilde_beta_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
SmoothSparsePhiConfig::mutable_background_tilde_beta() {
  return &background_tilde_beta_;
}

// -------------------------------------------------------------------

// DoubleArray

// repeated double value = 1;
inline int DoubleArray::value_size() const {
  return value_.size();
}
inline void DoubleArray::clear_value() {
  value_.Clear();
}
inline double DoubleArray::value(int index) const {
  return value_.Get(index);
}
inline void DoubleArray::set_value(int index, double value) {
  value_.Set(index, value);
}
inline void DoubleArray::add_value(double value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// Score

// required .artm.Score.Type type = 1;
inline bool Score::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Score::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Score::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Score::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::Score_Type Score::type() const {
  return static_cast< ::artm::Score_Type >(type_);
}
inline void Score::set_type(::artm::Score_Type value) {
  assert(::artm::Score_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string field_name = 2 [default = "@body"];
inline bool Score::has_field_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Score::set_has_field_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Score::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Score::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& Score::field_name() const {
  return *field_name_;
}
inline void Score::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void Score::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void Score::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Score::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* Score::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void Score::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 3 [default = "@global"];
inline bool Score::has_stream_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Score::set_has_stream_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Score::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Score::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& Score::stream_name() const {
  return *stream_name_;
}
inline void Score::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void Score::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void Score::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Score::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* Score::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void Score::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// -------------------------------------------------------------------

// LoggerConfig

// optional string log_location = 1;
inline bool LoggerConfig::has_log_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoggerConfig::set_has_log_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoggerConfig::clear_has_log_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoggerConfig::clear_log_location() {
  if (log_location_ != &::google::protobuf::internal::kEmptyString) {
    log_location_->clear();
  }
  clear_has_log_location();
}
inline const ::std::string& LoggerConfig::log_location() const {
  return *log_location_;
}
inline void LoggerConfig::set_log_location(const ::std::string& value) {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  log_location_->assign(value);
}
inline void LoggerConfig::set_log_location(const char* value) {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  log_location_->assign(value);
}
inline void LoggerConfig::set_log_location(const char* value, size_t size) {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  log_location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoggerConfig::mutable_log_location() {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  return log_location_;
}
inline ::std::string* LoggerConfig::release_log_location() {
  clear_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_location_;
    log_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoggerConfig::set_allocated_log_location(::std::string* log_location) {
  if (log_location_ != &::google::protobuf::internal::kEmptyString) {
    delete log_location_;
  }
  if (log_location) {
    set_has_log_location();
    log_location_ = log_location;
  } else {
    clear_has_log_location();
    log_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .artm.LoggerConfig.Level level = 2 [default = INFO];
inline bool LoggerConfig::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoggerConfig::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoggerConfig::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoggerConfig::clear_level() {
  level_ = 3;
  clear_has_level();
}
inline ::artm::LoggerConfig_Level LoggerConfig::level() const {
  return static_cast< ::artm::LoggerConfig_Level >(level_);
}
inline void LoggerConfig::set_level(::artm::LoggerConfig_Level value) {
  assert(::artm::LoggerConfig_Level_IsValid(value));
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// ModelTopics

// repeated .artm.TokenTopics token_topic = 1;
inline int ModelTopics::token_topic_size() const {
  return token_topic_.size();
}
inline void ModelTopics::clear_token_topic() {
  token_topic_.Clear();
}
inline const ::artm::TokenTopics& ModelTopics::token_topic(int index) const {
  return token_topic_.Get(index);
}
inline ::artm::TokenTopics* ModelTopics::mutable_token_topic(int index) {
  return token_topic_.Mutable(index);
}
inline ::artm::TokenTopics* ModelTopics::add_token_topic() {
  return token_topic_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::TokenTopics >&
ModelTopics::token_topic() const {
  return token_topic_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::TokenTopics >*
ModelTopics::mutable_token_topic() {
  return &token_topic_;
}

// optional int32 items_processed = 2;
inline bool ModelTopics::has_items_processed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelTopics::set_has_items_processed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelTopics::clear_has_items_processed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelTopics::clear_items_processed() {
  items_processed_ = 0;
  clear_has_items_processed();
}
inline ::google::protobuf::int32 ModelTopics::items_processed() const {
  return items_processed_;
}
inline void ModelTopics::set_items_processed(::google::protobuf::int32 value) {
  set_has_items_processed();
  items_processed_ = value;
}

// repeated double score = 3;
inline int ModelTopics::score_size() const {
  return score_.size();
}
inline void ModelTopics::clear_score() {
  score_.Clear();
}
inline double ModelTopics::score(int index) const {
  return score_.Get(index);
}
inline void ModelTopics::set_score(int index, double value) {
  score_.Set(index, value);
}
inline void ModelTopics::add_score(double value) {
  score_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ModelTopics::score() const {
  return score_;
}
inline ::google::protobuf::RepeatedField< double >*
ModelTopics::mutable_score() {
  return &score_;
}

// -------------------------------------------------------------------

// TokenTopics

// optional string token = 1;
inline bool TokenTopics::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenTopics::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenTopics::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenTopics::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& TokenTopics::token() const {
  return *token_;
}
inline void TokenTopics::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TokenTopics::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TokenTopics::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TokenTopics::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* TokenTopics::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TokenTopics::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 token_id = 2;
inline bool TokenTopics::has_token_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TokenTopics::set_has_token_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TokenTopics::clear_has_token_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TokenTopics::clear_token_id() {
  token_id_ = 0;
  clear_has_token_id();
}
inline ::google::protobuf::int32 TokenTopics::token_id() const {
  return token_id_;
}
inline void TokenTopics::set_token_id(::google::protobuf::int32 value) {
  set_has_token_id();
  token_id_ = value;
}

// repeated float topic_weight = 3;
inline int TokenTopics::topic_weight_size() const {
  return topic_weight_.size();
}
inline void TokenTopics::clear_topic_weight() {
  topic_weight_.Clear();
}
inline float TokenTopics::topic_weight(int index) const {
  return topic_weight_.Get(index);
}
inline void TokenTopics::set_topic_weight(int index, float value) {
  topic_weight_.Set(index, value);
}
inline void TokenTopics::add_topic_weight(float value) {
  topic_weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TokenTopics::topic_weight() const {
  return topic_weight_;
}
inline ::google::protobuf::RepeatedField< float >*
TokenTopics::mutable_topic_weight() {
  return &topic_weight_;
}

// -------------------------------------------------------------------

// ItemTopics

// optional int32 id = 1;
inline bool ItemTopics::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemTopics::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemTopics::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemTopics::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ItemTopics::id() const {
  return id_;
}
inline void ItemTopics::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated float topic_weight = 2;
inline int ItemTopics::topic_weight_size() const {
  return topic_weight_.size();
}
inline void ItemTopics::clear_topic_weight() {
  topic_weight_.Clear();
}
inline float ItemTopics::topic_weight(int index) const {
  return topic_weight_.Get(index);
}
inline void ItemTopics::set_topic_weight(int index, float value) {
  topic_weight_.Set(index, value);
}
inline void ItemTopics::add_topic_weight(float value) {
  topic_weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ItemTopics::topic_weight() const {
  return topic_weight_;
}
inline ::google::protobuf::RepeatedField< float >*
ItemTopics::mutable_topic_weight() {
  return &topic_weight_;
}

// -------------------------------------------------------------------

// BatchTopics

// repeated .artm.ItemTopics item_topics = 1;
inline int BatchTopics::item_topics_size() const {
  return item_topics_.size();
}
inline void BatchTopics::clear_item_topics() {
  item_topics_.Clear();
}
inline const ::artm::ItemTopics& BatchTopics::item_topics(int index) const {
  return item_topics_.Get(index);
}
inline ::artm::ItemTopics* BatchTopics::mutable_item_topics(int index) {
  return item_topics_.Mutable(index);
}
inline ::artm::ItemTopics* BatchTopics::add_item_topics() {
  return item_topics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::ItemTopics >&
BatchTopics::item_topics() const {
  return item_topics_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::ItemTopics >*
BatchTopics::mutable_item_topics() {
  return &item_topics_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace artm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::Stream_Type>() {
  return ::artm::Stream_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::RegularizerConfig_Type>() {
  return ::artm::RegularizerConfig_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::Score_Type>() {
  return ::artm::Score_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::LoggerConfig_Level>() {
  return ::artm::LoggerConfig_Level_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
