// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "memcached_service.rpcz.h"
#include "memcached_service.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/stubs/once.h>
#include <rpcz/rpcz.hpp>
namespace {
const ::google::protobuf::ServiceDescriptor* MemcachedService_descriptor_ = NULL;
const ::google::protobuf::ServiceDescriptor* BatchManagerService_descriptor_ = NULL;
}  // anonymouse namespace

namespace artm {
namespace memcached {

void rpcz_protobuf_AssignDesc_memcached_5fservice_2eproto() {
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "memcached_service.proto");
  GOOGLE_CHECK(file != NULL);
  MemcachedService_descriptor_ = file->service(0);
  BatchManagerService_descriptor_ = file->service(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &rpcz_protobuf_AssignDesc_memcached_5fservice_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
}

}  // namespace

void rpcz_protobuf_ShutdownFile_memcached_5fservice_2eproto() {
}

void rpcz_protobuf_AddDesc_memcached_5fservice_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::artm::protobuf_AddDesc_messages_2eproto();
  ::artm::core::protobuf_AddDesc_internals_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\027memcached_service.proto\022\016artm.memcache"
    "d\032\016messages.proto\032\017internals.proto\"\033\n\007Mo"
    "delId\022\020\n\010model_id\030\001 \002(\t\"\034\n\010BatchIds\022\020\n\010b"
    "atch_id\030\001 \003(\t\"\006\n\004Void\"\025\n\004Bool\022\r\n\005value\030\001"
    " \002(\0102\212\001\n\020MemcachedService\022:\n\013UpdateModel"
    "\022\031.artm.core.ModelIncrement\032\020.artm.Topic"
    "Model\022:\n\rRetrieveModel\022\027.artm.memcached."
    "ModelId\032\020.artm.TopicModel2\206\002\n\023BatchManag"
    "erService\022:\n\010Schedule\022\030.artm.memcached.B"
    "atchIds\032\024.artm.memcached.Void\0226\n\004Next\022\024."
    "artm.memcached.Void\032\030.artm.memcached.Bat"
    "chIds\0226\n\004Done\022\030.artm.memcached.BatchIds\032"
    "\024.artm.memcached.Void\022C\n\025IsEverythingPro"
    "cessed\022\024.artm.memcached.Void\032\024.artm.memc"
    "ached.Bool", 570);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "memcached_service.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&rpcz_protobuf_ShutdownFile_memcached_5fservice_2eproto);
}

// ===================================================================

MemcachedService::~MemcachedService() {}

const ::google::protobuf::ServiceDescriptor* MemcachedService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemcachedService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* MemcachedService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemcachedService_descriptor_;
}

void MemcachedService::UpdateModel(const ::artm::core::ModelIncrement&,
                         ::rpcz::reply< ::artm::TopicModel> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method UpdateModel() not implemented.");
}

void MemcachedService::RetrieveModel(const ::artm::memcached::ModelId&,
                         ::rpcz::reply< ::artm::TopicModel> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RetrieveModel() not implemented.");
}

void MemcachedService::call_method(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message& request,
                             ::rpcz::server_channel* channel) {
  GOOGLE_DCHECK_EQ(method->service(), MemcachedService_descriptor_);
  switch(method->index()) {
    case 0:
      UpdateModel(
          *::google::protobuf::down_cast<const ::artm::core::ModelIncrement*>(&request),
          ::rpcz::reply< ::artm::TopicModel>(channel));
      break;
    case 1:
      RetrieveModel(
          *::google::protobuf::down_cast<const ::artm::memcached::ModelId*>(&request),
          ::rpcz::reply< ::artm::TopicModel>(channel));
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& MemcachedService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::core::ModelIncrement::default_instance();
    case 1:
      return ::artm::memcached::ModelId::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& MemcachedService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::TopicModel::default_instance();
    case 1:
      return ::artm::TopicModel::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

MemcachedService_Stub::MemcachedService_Stub(::rpcz::rpc_channel* channel,
                                   const ::std::string& service_name,
                                   bool owns_channel)
  : channel_(channel), service_name_(service_name),
    owns_channel_(owns_channel) {}
MemcachedService_Stub::MemcachedService_Stub(::rpcz::rpc_channel* channel,
                                   bool owns_channel)
  : channel_(channel), service_name_(MemcachedService::descriptor()->name()),
    owns_channel_(owns_channel) {}
MemcachedService_Stub::~MemcachedService_Stub() {
  if (owns_channel_) delete channel_;
}

void MemcachedService_Stub::UpdateModel(const ::artm::core::ModelIncrement& request,
                              ::artm::TopicModel* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MemcachedService::descriptor()->method(0),
                        request, response, rpc, done);
}
void MemcachedService_Stub::UpdateModel(const ::artm::core::ModelIncrement& request,
                              ::artm::TopicModel* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MemcachedService::descriptor()->method(0),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MemcachedService_Stub::RetrieveModel(const ::artm::memcached::ModelId& request,
                              ::artm::TopicModel* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MemcachedService::descriptor()->method(1),
                        request, response, rpc, done);
}
void MemcachedService_Stub::RetrieveModel(const ::artm::memcached::ModelId& request,
                              ::artm::TopicModel* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MemcachedService::descriptor()->method(1),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
// ===================================================================

BatchManagerService::~BatchManagerService() {}

const ::google::protobuf::ServiceDescriptor* BatchManagerService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchManagerService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* BatchManagerService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchManagerService_descriptor_;
}

void BatchManagerService::Schedule(const ::artm::memcached::BatchIds&,
                         ::rpcz::reply< ::artm::memcached::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method Schedule() not implemented.");
}

void BatchManagerService::Next(const ::artm::memcached::Void&,
                         ::rpcz::reply< ::artm::memcached::BatchIds> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method Next() not implemented.");
}

void BatchManagerService::Done(const ::artm::memcached::BatchIds&,
                         ::rpcz::reply< ::artm::memcached::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method Done() not implemented.");
}

void BatchManagerService::IsEverythingProcessed(const ::artm::memcached::Void&,
                         ::rpcz::reply< ::artm::memcached::Bool> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method IsEverythingProcessed() not implemented.");
}

void BatchManagerService::call_method(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message& request,
                             ::rpcz::server_channel* channel) {
  GOOGLE_DCHECK_EQ(method->service(), BatchManagerService_descriptor_);
  switch(method->index()) {
    case 0:
      Schedule(
          *::google::protobuf::down_cast<const ::artm::memcached::BatchIds*>(&request),
          ::rpcz::reply< ::artm::memcached::Void>(channel));
      break;
    case 1:
      Next(
          *::google::protobuf::down_cast<const ::artm::memcached::Void*>(&request),
          ::rpcz::reply< ::artm::memcached::BatchIds>(channel));
      break;
    case 2:
      Done(
          *::google::protobuf::down_cast<const ::artm::memcached::BatchIds*>(&request),
          ::rpcz::reply< ::artm::memcached::Void>(channel));
      break;
    case 3:
      IsEverythingProcessed(
          *::google::protobuf::down_cast<const ::artm::memcached::Void*>(&request),
          ::rpcz::reply< ::artm::memcached::Bool>(channel));
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& BatchManagerService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::memcached::BatchIds::default_instance();
    case 1:
      return ::artm::memcached::Void::default_instance();
    case 2:
      return ::artm::memcached::BatchIds::default_instance();
    case 3:
      return ::artm::memcached::Void::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& BatchManagerService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::memcached::Void::default_instance();
    case 1:
      return ::artm::memcached::BatchIds::default_instance();
    case 2:
      return ::artm::memcached::Void::default_instance();
    case 3:
      return ::artm::memcached::Bool::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

BatchManagerService_Stub::BatchManagerService_Stub(::rpcz::rpc_channel* channel,
                                   const ::std::string& service_name,
                                   bool owns_channel)
  : channel_(channel), service_name_(service_name),
    owns_channel_(owns_channel) {}
BatchManagerService_Stub::BatchManagerService_Stub(::rpcz::rpc_channel* channel,
                                   bool owns_channel)
  : channel_(channel), service_name_(BatchManagerService::descriptor()->name()),
    owns_channel_(owns_channel) {}
BatchManagerService_Stub::~BatchManagerService_Stub() {
  if (owns_channel_) delete channel_;
}

void BatchManagerService_Stub::Schedule(const ::artm::memcached::BatchIds& request,
                              ::artm::memcached::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(0),
                        request, response, rpc, done);
}
void BatchManagerService_Stub::Schedule(const ::artm::memcached::BatchIds& request,
                              ::artm::memcached::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(0),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void BatchManagerService_Stub::Next(const ::artm::memcached::Void& request,
                              ::artm::memcached::BatchIds* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(1),
                        request, response, rpc, done);
}
void BatchManagerService_Stub::Next(const ::artm::memcached::Void& request,
                              ::artm::memcached::BatchIds* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(1),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void BatchManagerService_Stub::Done(const ::artm::memcached::BatchIds& request,
                              ::artm::memcached::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(2),
                        request, response, rpc, done);
}
void BatchManagerService_Stub::Done(const ::artm::memcached::BatchIds& request,
                              ::artm::memcached::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(2),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void BatchManagerService_Stub::IsEverythingProcessed(const ::artm::memcached::Void& request,
                              ::artm::memcached::Bool* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(3),
                        request, response, rpc, done);
}
void BatchManagerService_Stub::IsEverythingProcessed(const ::artm::memcached::Void& request,
                              ::artm::memcached::Bool* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        BatchManagerService::descriptor()->method(3),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}

}  // namespace memcached
}  // namespace artm
