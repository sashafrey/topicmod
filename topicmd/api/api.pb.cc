// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "api.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace topicmd {

namespace {

const ::google::protobuf::Descriptor* ItemsVector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemsVector_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemsVector_Item_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemsVector_Item_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ItemsVector_OperationType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Configuration_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Configuration_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Configuration_ProcessorType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LoggerConfiguration_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoggerConfiguration_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* LoggerConfiguration_Level_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ContractVersion_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_api_2eproto() {
  protobuf_AddDesc_api_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "api.proto");
  GOOGLE_CHECK(file != NULL);
  ItemsVector_descriptor_ = file->message_type(0);
  static const int ItemsVector_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector, contract_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector, tokens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector, items_),
  };
  ItemsVector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemsVector_descriptor_,
      ItemsVector::default_instance_,
      ItemsVector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemsVector));
  ItemsVector_Item_descriptor_ = ItemsVector_descriptor_->nested_type(0);
  static const int ItemsVector_Item_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector_Item, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector_Item, operation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector_Item, token_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector_Item, token_counts_),
  };
  ItemsVector_Item_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemsVector_Item_descriptor_,
      ItemsVector_Item::default_instance_,
      ItemsVector_Item_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector_Item, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemsVector_Item, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemsVector_Item));
  ItemsVector_OperationType_descriptor_ = ItemsVector_descriptor_->enum_type(0);
  Configuration_descriptor_ = file->message_type(1);
  static const int Configuration_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Configuration, contract_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Configuration, index_location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Configuration, process_items_on_publish_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Configuration, index_readers_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Configuration, processors_count_),
  };
  Configuration_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Configuration_descriptor_,
      Configuration::default_instance_,
      Configuration_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Configuration, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Configuration, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Configuration));
  Configuration_ProcessorType_descriptor_ = Configuration_descriptor_->enum_type(0);
  LoggerConfiguration_descriptor_ = file->message_type(2);
  static const int LoggerConfiguration_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggerConfiguration, log_location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggerConfiguration, level_),
  };
  LoggerConfiguration_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoggerConfiguration_descriptor_,
      LoggerConfiguration::default_instance_,
      LoggerConfiguration_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggerConfiguration, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggerConfiguration, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoggerConfiguration));
  LoggerConfiguration_Level_descriptor_ = LoggerConfiguration_descriptor_->enum_type(0);
  ContractVersion_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_api_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemsVector_descriptor_, &ItemsVector::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemsVector_Item_descriptor_, &ItemsVector_Item::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Configuration_descriptor_, &Configuration::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoggerConfiguration_descriptor_, &LoggerConfiguration::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_api_2eproto() {
  delete ItemsVector::default_instance_;
  delete ItemsVector_reflection_;
  delete ItemsVector_Item::default_instance_;
  delete ItemsVector_Item_reflection_;
  delete Configuration::default_instance_;
  delete Configuration_reflection_;
  delete LoggerConfiguration::default_instance_;
  delete LoggerConfiguration_reflection_;
}

void protobuf_AddDesc_api_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tapi.proto\022\007topicmd\"\262\002\n\013ItemsVector\0228\n\020"
    "contract_version\030\001 \001(\0162\030.topicmd.Contrac"
    "tVersion:\004V_01\022\016\n\006tokens\030\002 \003(\t\022(\n\005items\030"
    "\003 \003(\0132\031.topicmd.ItemsVector.Item\032z\n\004Item"
    "\022\n\n\002id\030\001 \001(\005\022=\n\toperation\030\002 \001(\0162\".topicm"
    "d.ItemsVector.OperationType:\006INSERT\022\021\n\tt"
    "oken_ids\030\003 \003(\005\022\024\n\014token_counts\030\004 \003(\005\"3\n\r"
    "OperationType\022\n\n\006INSERT\020\000\022\n\n\006UPDATE\020\001\022\n\n"
    "\006DELETE\020\002\"\350\001\n\rConfiguration\0228\n\020contract_"
    "version\030\001 \001(\0162\030.topicmd.ContractVersion:"
    "\004V_01\022\026\n\016index_location\030\002 \001(\t\022\'\n\030process"
    "_items_on_publish\030\003 \001(\010:\005false\022\036\n\023index_"
    "readers_count\030\004 \001(\005:\0011\022\033\n\020processors_cou"
    "nt\030\005 \001(\005:\0011\"\037\n\rProcessorType\022\016\n\nBATCH_PL"
    "SA\020\000\"\234\001\n\023LoggerConfiguration\022\024\n\014log_loca"
    "tion\030\001 \001(\t\0227\n\005level\030\002 \001(\0162\".topicmd.Logg"
    "erConfiguration.Level:\004INFO\"6\n\005Level\022\t\n\005"
    "ERROR\020\001\022\013\n\007WARNING\020\002\022\010\n\004INFO\020\003\022\013\n\007VERBOS"
    "E\020\004*\033\n\017ContractVersion\022\010\n\004V_01\020\000", 752);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "api.proto", &protobuf_RegisterTypes);
  ItemsVector::default_instance_ = new ItemsVector();
  ItemsVector_Item::default_instance_ = new ItemsVector_Item();
  Configuration::default_instance_ = new Configuration();
  LoggerConfiguration::default_instance_ = new LoggerConfiguration();
  ItemsVector::default_instance_->InitAsDefaultInstance();
  ItemsVector_Item::default_instance_->InitAsDefaultInstance();
  Configuration::default_instance_->InitAsDefaultInstance();
  LoggerConfiguration::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_api_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_api_2eproto {
  StaticDescriptorInitializer_api_2eproto() {
    protobuf_AddDesc_api_2eproto();
  }
} static_descriptor_initializer_api_2eproto_;
const ::google::protobuf::EnumDescriptor* ContractVersion_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContractVersion_descriptor_;
}
bool ContractVersion_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ItemsVector_OperationType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemsVector_OperationType_descriptor_;
}
bool ItemsVector_OperationType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ItemsVector_OperationType ItemsVector::INSERT;
const ItemsVector_OperationType ItemsVector::UPDATE;
const ItemsVector_OperationType ItemsVector::DELETE;
const ItemsVector_OperationType ItemsVector::OperationType_MIN;
const ItemsVector_OperationType ItemsVector::OperationType_MAX;
const int ItemsVector::OperationType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ItemsVector_Item::kIdFieldNumber;
const int ItemsVector_Item::kOperationFieldNumber;
const int ItemsVector_Item::kTokenIdsFieldNumber;
const int ItemsVector_Item::kTokenCountsFieldNumber;
#endif  // !_MSC_VER

ItemsVector_Item::ItemsVector_Item()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ItemsVector_Item::InitAsDefaultInstance() {
}

ItemsVector_Item::ItemsVector_Item(const ItemsVector_Item& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ItemsVector_Item::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  operation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemsVector_Item::~ItemsVector_Item() {
  SharedDtor();
}

void ItemsVector_Item::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemsVector_Item::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemsVector_Item::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemsVector_Item_descriptor_;
}

const ItemsVector_Item& ItemsVector_Item::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_api_2eproto();
  return *default_instance_;
}

ItemsVector_Item* ItemsVector_Item::default_instance_ = NULL;

ItemsVector_Item* ItemsVector_Item::New() const {
  return new ItemsVector_Item;
}

void ItemsVector_Item::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    operation_ = 0;
  }
  token_ids_.Clear();
  token_counts_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemsVector_Item::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_operation;
        break;
      }

      // optional .topicmd.ItemsVector.OperationType operation = 2 [default = INSERT];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_operation:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::topicmd::ItemsVector_OperationType_IsValid(value)) {
            set_operation(static_cast< ::topicmd::ItemsVector_OperationType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_token_ids;
        break;
      }

      // repeated int32 token_ids = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_token_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_token_ids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_token_ids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_token_ids;
        if (input->ExpectTag(32)) goto parse_token_counts;
        break;
      }

      // repeated int32 token_counts = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_token_counts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_token_counts())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_token_counts())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_token_counts;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemsVector_Item::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional .topicmd.ItemsVector.OperationType operation = 2 [default = INSERT];
  if (has_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->operation(), output);
  }

  // repeated int32 token_ids = 3;
  for (int i = 0; i < this->token_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->token_ids(i), output);
  }

  // repeated int32 token_counts = 4;
  for (int i = 0; i < this->token_counts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->token_counts(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ItemsVector_Item::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional .topicmd.ItemsVector.OperationType operation = 2 [default = INSERT];
  if (has_operation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->operation(), target);
  }

  // repeated int32 token_ids = 3;
  for (int i = 0; i < this->token_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->token_ids(i), target);
  }

  // repeated int32 token_counts = 4;
  for (int i = 0; i < this->token_counts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->token_counts(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ItemsVector_Item::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional .topicmd.ItemsVector.OperationType operation = 2 [default = INSERT];
    if (has_operation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
    }

  }
  // repeated int32 token_ids = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->token_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->token_ids(i));
    }
    total_size += 1 * this->token_ids_size() + data_size;
  }

  // repeated int32 token_counts = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->token_counts_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->token_counts(i));
    }
    total_size += 1 * this->token_counts_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemsVector_Item::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemsVector_Item* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemsVector_Item*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemsVector_Item::MergeFrom(const ItemsVector_Item& from) {
  GOOGLE_CHECK_NE(&from, this);
  token_ids_.MergeFrom(from.token_ids_);
  token_counts_.MergeFrom(from.token_counts_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_operation()) {
      set_operation(from.operation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemsVector_Item::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemsVector_Item::CopyFrom(const ItemsVector_Item& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemsVector_Item::IsInitialized() const {

  return true;
}

void ItemsVector_Item::Swap(ItemsVector_Item* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(operation_, other->operation_);
    token_ids_.Swap(&other->token_ids_);
    token_counts_.Swap(&other->token_counts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemsVector_Item::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemsVector_Item_descriptor_;
  metadata.reflection = ItemsVector_Item_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ItemsVector::kContractVersionFieldNumber;
const int ItemsVector::kTokensFieldNumber;
const int ItemsVector::kItemsFieldNumber;
#endif  // !_MSC_VER

ItemsVector::ItemsVector()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ItemsVector::InitAsDefaultInstance() {
}

ItemsVector::ItemsVector(const ItemsVector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ItemsVector::SharedCtor() {
  _cached_size_ = 0;
  contract_version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemsVector::~ItemsVector() {
  SharedDtor();
}

void ItemsVector::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemsVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemsVector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemsVector_descriptor_;
}

const ItemsVector& ItemsVector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_api_2eproto();
  return *default_instance_;
}

ItemsVector* ItemsVector::default_instance_ = NULL;

ItemsVector* ItemsVector::New() const {
  return new ItemsVector;
}

void ItemsVector::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    contract_version_ = 0;
  }
  tokens_.Clear();
  items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemsVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::topicmd::ContractVersion_IsValid(value)) {
            set_contract_version(static_cast< ::topicmd::ContractVersion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tokens;
        break;
      }

      // repeated string tokens = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tokens:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_tokens()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->tokens(this->tokens_size() - 1).data(),
            this->tokens(this->tokens_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tokens;
        if (input->ExpectTag(26)) goto parse_items;
        break;
      }

      // repeated .topicmd.ItemsVector.Item items = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_items()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_items;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemsVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
  if (has_contract_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->contract_version(), output);
  }

  // repeated string tokens = 2;
  for (int i = 0; i < this->tokens_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->tokens(i).data(), this->tokens(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->tokens(i), output);
  }

  // repeated .topicmd.ItemsVector.Item items = 3;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->items(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ItemsVector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
  if (has_contract_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->contract_version(), target);
  }

  // repeated string tokens = 2;
  for (int i = 0; i < this->tokens_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tokens(i).data(), this->tokens(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->tokens(i), target);
  }

  // repeated .topicmd.ItemsVector.Item items = 3;
  for (int i = 0; i < this->items_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->items(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ItemsVector::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
    if (has_contract_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->contract_version());
    }

  }
  // repeated string tokens = 2;
  total_size += 1 * this->tokens_size();
  for (int i = 0; i < this->tokens_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->tokens(i));
  }

  // repeated .topicmd.ItemsVector.Item items = 3;
  total_size += 1 * this->items_size();
  for (int i = 0; i < this->items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->items(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemsVector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemsVector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemsVector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemsVector::MergeFrom(const ItemsVector& from) {
  GOOGLE_CHECK_NE(&from, this);
  tokens_.MergeFrom(from.tokens_);
  items_.MergeFrom(from.items_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_contract_version()) {
      set_contract_version(from.contract_version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemsVector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemsVector::CopyFrom(const ItemsVector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemsVector::IsInitialized() const {

  return true;
}

void ItemsVector::Swap(ItemsVector* other) {
  if (other != this) {
    std::swap(contract_version_, other->contract_version_);
    tokens_.Swap(&other->tokens_);
    items_.Swap(&other->items_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemsVector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemsVector_descriptor_;
  metadata.reflection = ItemsVector_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Configuration_ProcessorType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Configuration_ProcessorType_descriptor_;
}
bool Configuration_ProcessorType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Configuration_ProcessorType Configuration::BATCH_PLSA;
const Configuration_ProcessorType Configuration::ProcessorType_MIN;
const Configuration_ProcessorType Configuration::ProcessorType_MAX;
const int Configuration::ProcessorType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Configuration::kContractVersionFieldNumber;
const int Configuration::kIndexLocationFieldNumber;
const int Configuration::kProcessItemsOnPublishFieldNumber;
const int Configuration::kIndexReadersCountFieldNumber;
const int Configuration::kProcessorsCountFieldNumber;
#endif  // !_MSC_VER

Configuration::Configuration()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Configuration::InitAsDefaultInstance() {
}

Configuration::Configuration(const Configuration& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Configuration::SharedCtor() {
  _cached_size_ = 0;
  contract_version_ = 0;
  index_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  process_items_on_publish_ = false;
  index_readers_count_ = 1;
  processors_count_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Configuration::~Configuration() {
  SharedDtor();
}

void Configuration::SharedDtor() {
  if (index_location_ != &::google::protobuf::internal::kEmptyString) {
    delete index_location_;
  }
  if (this != default_instance_) {
  }
}

void Configuration::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Configuration::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Configuration_descriptor_;
}

const Configuration& Configuration::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_api_2eproto();
  return *default_instance_;
}

Configuration* Configuration::default_instance_ = NULL;

Configuration* Configuration::New() const {
  return new Configuration;
}

void Configuration::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    contract_version_ = 0;
    if (has_index_location()) {
      if (index_location_ != &::google::protobuf::internal::kEmptyString) {
        index_location_->clear();
      }
    }
    process_items_on_publish_ = false;
    index_readers_count_ = 1;
    processors_count_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Configuration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::topicmd::ContractVersion_IsValid(value)) {
            set_contract_version(static_cast< ::topicmd::ContractVersion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_index_location;
        break;
      }

      // optional string index_location = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_index_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_index_location()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->index_location().data(), this->index_location().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_process_items_on_publish;
        break;
      }

      // optional bool process_items_on_publish = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_process_items_on_publish:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &process_items_on_publish_)));
          set_has_process_items_on_publish();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_index_readers_count;
        break;
      }

      // optional int32 index_readers_count = 4 [default = 1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index_readers_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_readers_count_)));
          set_has_index_readers_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_processors_count;
        break;
      }

      // optional int32 processors_count = 5 [default = 1];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_processors_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &processors_count_)));
          set_has_processors_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Configuration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
  if (has_contract_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->contract_version(), output);
  }

  // optional string index_location = 2;
  if (has_index_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->index_location().data(), this->index_location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->index_location(), output);
  }

  // optional bool process_items_on_publish = 3 [default = false];
  if (has_process_items_on_publish()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->process_items_on_publish(), output);
  }

  // optional int32 index_readers_count = 4 [default = 1];
  if (has_index_readers_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->index_readers_count(), output);
  }

  // optional int32 processors_count = 5 [default = 1];
  if (has_processors_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->processors_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Configuration::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
  if (has_contract_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->contract_version(), target);
  }

  // optional string index_location = 2;
  if (has_index_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->index_location().data(), this->index_location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->index_location(), target);
  }

  // optional bool process_items_on_publish = 3 [default = false];
  if (has_process_items_on_publish()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->process_items_on_publish(), target);
  }

  // optional int32 index_readers_count = 4 [default = 1];
  if (has_index_readers_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->index_readers_count(), target);
  }

  // optional int32 processors_count = 5 [default = 1];
  if (has_processors_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->processors_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Configuration::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
    if (has_contract_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->contract_version());
    }

    // optional string index_location = 2;
    if (has_index_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->index_location());
    }

    // optional bool process_items_on_publish = 3 [default = false];
    if (has_process_items_on_publish()) {
      total_size += 1 + 1;
    }

    // optional int32 index_readers_count = 4 [default = 1];
    if (has_index_readers_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index_readers_count());
    }

    // optional int32 processors_count = 5 [default = 1];
    if (has_processors_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->processors_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Configuration::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Configuration* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Configuration*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Configuration::MergeFrom(const Configuration& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_contract_version()) {
      set_contract_version(from.contract_version());
    }
    if (from.has_index_location()) {
      set_index_location(from.index_location());
    }
    if (from.has_process_items_on_publish()) {
      set_process_items_on_publish(from.process_items_on_publish());
    }
    if (from.has_index_readers_count()) {
      set_index_readers_count(from.index_readers_count());
    }
    if (from.has_processors_count()) {
      set_processors_count(from.processors_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Configuration::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Configuration::CopyFrom(const Configuration& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Configuration::IsInitialized() const {

  return true;
}

void Configuration::Swap(Configuration* other) {
  if (other != this) {
    std::swap(contract_version_, other->contract_version_);
    std::swap(index_location_, other->index_location_);
    std::swap(process_items_on_publish_, other->process_items_on_publish_);
    std::swap(index_readers_count_, other->index_readers_count_);
    std::swap(processors_count_, other->processors_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Configuration::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Configuration_descriptor_;
  metadata.reflection = Configuration_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* LoggerConfiguration_Level_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoggerConfiguration_Level_descriptor_;
}
bool LoggerConfiguration_Level_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const LoggerConfiguration_Level LoggerConfiguration::ERROR;
const LoggerConfiguration_Level LoggerConfiguration::WARNING;
const LoggerConfiguration_Level LoggerConfiguration::INFO;
const LoggerConfiguration_Level LoggerConfiguration::VERBOSE;
const LoggerConfiguration_Level LoggerConfiguration::Level_MIN;
const LoggerConfiguration_Level LoggerConfiguration::Level_MAX;
const int LoggerConfiguration::Level_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int LoggerConfiguration::kLogLocationFieldNumber;
const int LoggerConfiguration::kLevelFieldNumber;
#endif  // !_MSC_VER

LoggerConfiguration::LoggerConfiguration()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoggerConfiguration::InitAsDefaultInstance() {
}

LoggerConfiguration::LoggerConfiguration(const LoggerConfiguration& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoggerConfiguration::SharedCtor() {
  _cached_size_ = 0;
  log_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  level_ = 3;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoggerConfiguration::~LoggerConfiguration() {
  SharedDtor();
}

void LoggerConfiguration::SharedDtor() {
  if (log_location_ != &::google::protobuf::internal::kEmptyString) {
    delete log_location_;
  }
  if (this != default_instance_) {
  }
}

void LoggerConfiguration::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoggerConfiguration::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoggerConfiguration_descriptor_;
}

const LoggerConfiguration& LoggerConfiguration::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_api_2eproto();
  return *default_instance_;
}

LoggerConfiguration* LoggerConfiguration::default_instance_ = NULL;

LoggerConfiguration* LoggerConfiguration::New() const {
  return new LoggerConfiguration;
}

void LoggerConfiguration::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_log_location()) {
      if (log_location_ != &::google::protobuf::internal::kEmptyString) {
        log_location_->clear();
      }
    }
    level_ = 3;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoggerConfiguration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string log_location = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_log_location()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->log_location().data(), this->log_location().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // optional .topicmd.LoggerConfiguration.Level level = 2 [default = INFO];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::topicmd::LoggerConfiguration_Level_IsValid(value)) {
            set_level(static_cast< ::topicmd::LoggerConfiguration_Level >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoggerConfiguration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string log_location = 1;
  if (has_log_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->log_location().data(), this->log_location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->log_location(), output);
  }

  // optional .topicmd.LoggerConfiguration.Level level = 2 [default = INFO];
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->level(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoggerConfiguration::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string log_location = 1;
  if (has_log_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->log_location().data(), this->log_location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->log_location(), target);
  }

  // optional .topicmd.LoggerConfiguration.Level level = 2 [default = INFO];
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->level(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoggerConfiguration::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string log_location = 1;
    if (has_log_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->log_location());
    }

    // optional .topicmd.LoggerConfiguration.Level level = 2 [default = INFO];
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->level());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoggerConfiguration::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoggerConfiguration* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoggerConfiguration*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoggerConfiguration::MergeFrom(const LoggerConfiguration& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_log_location()) {
      set_log_location(from.log_location());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoggerConfiguration::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoggerConfiguration::CopyFrom(const LoggerConfiguration& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoggerConfiguration::IsInitialized() const {

  return true;
}

void LoggerConfiguration::Swap(LoggerConfiguration* other) {
  if (other != this) {
    std::swap(log_location_, other->log_location_);
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoggerConfiguration::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoggerConfiguration_descriptor_;
  metadata.reflection = LoggerConfiguration_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace topicmd

// @@protoc_insertion_point(global_scope)
