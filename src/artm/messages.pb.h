// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: artm/messages.proto

#ifndef PROTOBUF_artm_2fmessages_2eproto__INCLUDED
#define PROTOBUF_artm_2fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace artm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_artm_2fmessages_2eproto();
void protobuf_AssignDesc_artm_2fmessages_2eproto();
void protobuf_ShutdownFile_artm_2fmessages_2eproto();

class Item;
class Field;
class Batch;
class Stream;
class MasterComponentConfig;
class MasterProxyConfig;
class ModelConfig;
class RegularizerConfig;
class DirichletThetaConfig;
class DirichletPhiConfig;
class SmoothSparseThetaConfig;
class SmoothSparsePhiConfig;
class DecorrelatorPhiConfig;
class DictionaryConfig;
class DictionaryEntry;
class DoubleArray;
class FloatArray;
class BoolArray;
class ScoreConfig;
class ScoreData;
class PerplexityScoreConfig;
class PerplexityScore;
class TopicModel;
class TopicModel_TopicModelInternals;
class ThetaMatrix;
class NodeControllerConfig;

enum Stream_Type {
  Stream_Type_Global = 0,
  Stream_Type_ItemIdModulus = 1
};
bool Stream_Type_IsValid(int value);
const Stream_Type Stream_Type_Type_MIN = Stream_Type_Global;
const Stream_Type Stream_Type_Type_MAX = Stream_Type_ItemIdModulus;
const int Stream_Type_Type_ARRAYSIZE = Stream_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Stream_Type_descriptor();
inline const ::std::string& Stream_Type_Name(Stream_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Stream_Type_descriptor(), value);
}
inline bool Stream_Type_Parse(
    const ::std::string& name, Stream_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Stream_Type>(
    Stream_Type_descriptor(), name, value);
}
enum MasterComponentConfig_ModusOperandi {
  MasterComponentConfig_ModusOperandi_Local = 0,
  MasterComponentConfig_ModusOperandi_Network = 1
};
bool MasterComponentConfig_ModusOperandi_IsValid(int value);
const MasterComponentConfig_ModusOperandi MasterComponentConfig_ModusOperandi_ModusOperandi_MIN = MasterComponentConfig_ModusOperandi_Local;
const MasterComponentConfig_ModusOperandi MasterComponentConfig_ModusOperandi_ModusOperandi_MAX = MasterComponentConfig_ModusOperandi_Network;
const int MasterComponentConfig_ModusOperandi_ModusOperandi_ARRAYSIZE = MasterComponentConfig_ModusOperandi_ModusOperandi_MAX + 1;

const ::google::protobuf::EnumDescriptor* MasterComponentConfig_ModusOperandi_descriptor();
inline const ::std::string& MasterComponentConfig_ModusOperandi_Name(MasterComponentConfig_ModusOperandi value) {
  return ::google::protobuf::internal::NameOfEnum(
    MasterComponentConfig_ModusOperandi_descriptor(), value);
}
inline bool MasterComponentConfig_ModusOperandi_Parse(
    const ::std::string& name, MasterComponentConfig_ModusOperandi* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MasterComponentConfig_ModusOperandi>(
    MasterComponentConfig_ModusOperandi_descriptor(), name, value);
}
enum RegularizerConfig_Type {
  RegularizerConfig_Type_DirichletTheta = 0,
  RegularizerConfig_Type_DirichletPhi = 1,
  RegularizerConfig_Type_SmoothSparseTheta = 2,
  RegularizerConfig_Type_SmoothSparsePhi = 3,
  RegularizerConfig_Type_DecorrelatorPhi = 4
};
bool RegularizerConfig_Type_IsValid(int value);
const RegularizerConfig_Type RegularizerConfig_Type_Type_MIN = RegularizerConfig_Type_DirichletTheta;
const RegularizerConfig_Type RegularizerConfig_Type_Type_MAX = RegularizerConfig_Type_DecorrelatorPhi;
const int RegularizerConfig_Type_Type_ARRAYSIZE = RegularizerConfig_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegularizerConfig_Type_descriptor();
inline const ::std::string& RegularizerConfig_Type_Name(RegularizerConfig_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegularizerConfig_Type_descriptor(), value);
}
inline bool RegularizerConfig_Type_Parse(
    const ::std::string& name, RegularizerConfig_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegularizerConfig_Type>(
    RegularizerConfig_Type_descriptor(), name, value);
}
enum ScoreConfig_Type {
  ScoreConfig_Type_Perplexity = 0
};
bool ScoreConfig_Type_IsValid(int value);
const ScoreConfig_Type ScoreConfig_Type_Type_MIN = ScoreConfig_Type_Perplexity;
const ScoreConfig_Type ScoreConfig_Type_Type_MAX = ScoreConfig_Type_Perplexity;
const int ScoreConfig_Type_Type_ARRAYSIZE = ScoreConfig_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScoreConfig_Type_descriptor();
inline const ::std::string& ScoreConfig_Type_Name(ScoreConfig_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScoreConfig_Type_descriptor(), value);
}
inline bool ScoreConfig_Type_Parse(
    const ::std::string& name, ScoreConfig_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScoreConfig_Type>(
    ScoreConfig_Type_descriptor(), name, value);
}
enum ScoreData_Type {
  ScoreData_Type_Perplexity = 0
};
bool ScoreData_Type_IsValid(int value);
const ScoreData_Type ScoreData_Type_Type_MIN = ScoreData_Type_Perplexity;
const ScoreData_Type ScoreData_Type_Type_MAX = ScoreData_Type_Perplexity;
const int ScoreData_Type_Type_ARRAYSIZE = ScoreData_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScoreData_Type_descriptor();
inline const ::std::string& ScoreData_Type_Name(ScoreData_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScoreData_Type_descriptor(), value);
}
inline bool ScoreData_Type_Parse(
    const ::std::string& name, ScoreData_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScoreData_Type>(
    ScoreData_Type_descriptor(), name, value);
}
// ===================================================================

class Item : public ::google::protobuf::Message {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .artm.Field field = 2;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 2;
  inline const ::artm::Field& field(int index) const;
  inline ::artm::Field* mutable_field(int index);
  inline ::artm::Field* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Field >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Field >*
      mutable_field();

  // @@protoc_insertion_point(class_scope:artm.Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::Field > field_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "@body"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 token_id = 2;
  inline int token_id_size() const;
  inline void clear_token_id();
  static const int kTokenIdFieldNumber = 2;
  inline ::google::protobuf::int32 token_id(int index) const;
  inline void set_token_id(int index, ::google::protobuf::int32 value);
  inline void add_token_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_id();

  // repeated int32 token_count = 3;
  inline int token_count_size() const;
  inline void clear_token_count();
  static const int kTokenCountFieldNumber = 3;
  inline ::google::protobuf::int32 token_count(int index) const;
  inline void set_token_count(int index, ::google::protobuf::int32 value);
  inline void add_token_count(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_count() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_count();

  // @@protoc_insertion_point(class_scope:artm.Field)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class Batch : public ::google::protobuf::Message {
 public:
  Batch();
  virtual ~Batch();

  Batch(const Batch& from);

  inline Batch& operator=(const Batch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Batch& default_instance();

  void Swap(Batch* other);

  // implements Message ----------------------------------------------

  Batch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Batch& from);
  void MergeFrom(const Batch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string token = 1;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated .artm.Item item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::artm::Item& item(int index) const;
  inline ::artm::Item* mutable_item(int index);
  inline ::artm::Item* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Item >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Item >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:artm.Batch)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::artm::Item > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Batch* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  void Swap(Stream* other);

  // implements Message ----------------------------------------------

  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Stream_Type Type;
  static const Type Global = Stream_Type_Global;
  static const Type ItemIdModulus = Stream_Type_ItemIdModulus;
  static inline bool Type_IsValid(int value) {
    return Stream_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Stream_Type_Type_MIN;
  static const Type Type_MAX =
    Stream_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Stream_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Stream_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Stream_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Stream_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .artm.Stream.Type type = 1 [default = Global];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::artm::Stream_Type type() const;
  inline void set_type(::artm::Stream_Type value);

  // optional string name = 2 [default = "@global"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 modulus = 3;
  inline bool has_modulus() const;
  inline void clear_modulus();
  static const int kModulusFieldNumber = 3;
  inline ::google::protobuf::int32 modulus() const;
  inline void set_modulus(::google::protobuf::int32 value);

  // repeated int32 residuals = 4;
  inline int residuals_size() const;
  inline void clear_residuals();
  static const int kResidualsFieldNumber = 4;
  inline ::google::protobuf::int32 residuals(int index) const;
  inline void set_residuals(int index, ::google::protobuf::int32 value);
  inline void add_residuals(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      residuals() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_residuals();

  // @@protoc_insertion_point(class_scope:artm.Stream)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_modulus();
  inline void clear_has_modulus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  int type_;
  ::google::protobuf::int32 modulus_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > residuals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class MasterComponentConfig : public ::google::protobuf::Message {
 public:
  MasterComponentConfig();
  virtual ~MasterComponentConfig();

  MasterComponentConfig(const MasterComponentConfig& from);

  inline MasterComponentConfig& operator=(const MasterComponentConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterComponentConfig& default_instance();

  void Swap(MasterComponentConfig* other);

  // implements Message ----------------------------------------------

  MasterComponentConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterComponentConfig& from);
  void MergeFrom(const MasterComponentConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MasterComponentConfig_ModusOperandi ModusOperandi;
  static const ModusOperandi Local = MasterComponentConfig_ModusOperandi_Local;
  static const ModusOperandi Network = MasterComponentConfig_ModusOperandi_Network;
  static inline bool ModusOperandi_IsValid(int value) {
    return MasterComponentConfig_ModusOperandi_IsValid(value);
  }
  static const ModusOperandi ModusOperandi_MIN =
    MasterComponentConfig_ModusOperandi_ModusOperandi_MIN;
  static const ModusOperandi ModusOperandi_MAX =
    MasterComponentConfig_ModusOperandi_ModusOperandi_MAX;
  static const int ModusOperandi_ARRAYSIZE =
    MasterComponentConfig_ModusOperandi_ModusOperandi_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModusOperandi_descriptor() {
    return MasterComponentConfig_ModusOperandi_descriptor();
  }
  static inline const ::std::string& ModusOperandi_Name(ModusOperandi value) {
    return MasterComponentConfig_ModusOperandi_Name(value);
  }
  static inline bool ModusOperandi_Parse(const ::std::string& name,
      ModusOperandi* value) {
    return MasterComponentConfig_ModusOperandi_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string disk_path = 1;
  inline bool has_disk_path() const;
  inline void clear_disk_path();
  static const int kDiskPathFieldNumber = 1;
  inline const ::std::string& disk_path() const;
  inline void set_disk_path(const ::std::string& value);
  inline void set_disk_path(const char* value);
  inline void set_disk_path(const char* value, size_t size);
  inline ::std::string* mutable_disk_path();
  inline ::std::string* release_disk_path();
  inline void set_allocated_disk_path(::std::string* disk_path);

  // repeated .artm.Stream stream = 2;
  inline int stream_size() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline const ::artm::Stream& stream(int index) const;
  inline ::artm::Stream* mutable_stream(int index);
  inline ::artm::Stream* add_stream();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Stream >&
      stream() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Stream >*
      mutable_stream();

  // optional bool compact_batches = 3 [default = true];
  inline bool has_compact_batches() const;
  inline void clear_compact_batches();
  static const int kCompactBatchesFieldNumber = 3;
  inline bool compact_batches() const;
  inline void set_compact_batches(bool value);

  // optional bool cache_processor_output = 4 [default = false];
  inline bool has_cache_processor_output() const;
  inline void clear_cache_processor_output();
  static const int kCacheProcessorOutputFieldNumber = 4;
  inline bool cache_processor_output() const;
  inline void set_cache_processor_output(bool value);

  // optional int32 processors_count = 5 [default = 1];
  inline bool has_processors_count() const;
  inline void clear_processors_count();
  static const int kProcessorsCountFieldNumber = 5;
  inline ::google::protobuf::int32 processors_count() const;
  inline void set_processors_count(::google::protobuf::int32 value);

  // optional int32 processor_queue_max_size = 6 [default = 10];
  inline bool has_processor_queue_max_size() const;
  inline void clear_processor_queue_max_size();
  static const int kProcessorQueueMaxSizeFieldNumber = 6;
  inline ::google::protobuf::int32 processor_queue_max_size() const;
  inline void set_processor_queue_max_size(::google::protobuf::int32 value);

  // optional int32 merger_queue_max_size = 7 [default = 10];
  inline bool has_merger_queue_max_size() const;
  inline void clear_merger_queue_max_size();
  static const int kMergerQueueMaxSizeFieldNumber = 7;
  inline ::google::protobuf::int32 merger_queue_max_size() const;
  inline void set_merger_queue_max_size(::google::protobuf::int32 value);

  // repeated .artm.ScoreConfig score_config = 8;
  inline int score_config_size() const;
  inline void clear_score_config();
  static const int kScoreConfigFieldNumber = 8;
  inline const ::artm::ScoreConfig& score_config(int index) const;
  inline ::artm::ScoreConfig* mutable_score_config(int index);
  inline ::artm::ScoreConfig* add_score_config();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >&
      score_config() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >*
      mutable_score_config();

  // optional .artm.MasterComponentConfig.ModusOperandi modus_operandi = 100 [default = Local];
  inline bool has_modus_operandi() const;
  inline void clear_modus_operandi();
  static const int kModusOperandiFieldNumber = 100;
  inline ::artm::MasterComponentConfig_ModusOperandi modus_operandi() const;
  inline void set_modus_operandi(::artm::MasterComponentConfig_ModusOperandi value);

  // optional string create_endpoint = 101;
  inline bool has_create_endpoint() const;
  inline void clear_create_endpoint();
  static const int kCreateEndpointFieldNumber = 101;
  inline const ::std::string& create_endpoint() const;
  inline void set_create_endpoint(const ::std::string& value);
  inline void set_create_endpoint(const char* value);
  inline void set_create_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_create_endpoint();
  inline ::std::string* release_create_endpoint();
  inline void set_allocated_create_endpoint(::std::string* create_endpoint);

  // optional string connect_endpoint = 102;
  inline bool has_connect_endpoint() const;
  inline void clear_connect_endpoint();
  static const int kConnectEndpointFieldNumber = 102;
  inline const ::std::string& connect_endpoint() const;
  inline void set_connect_endpoint(const ::std::string& value);
  inline void set_connect_endpoint(const char* value);
  inline void set_connect_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_connect_endpoint();
  inline ::std::string* release_connect_endpoint();
  inline void set_allocated_connect_endpoint(::std::string* connect_endpoint);

  // repeated string node_connect_endpoint = 103;
  inline int node_connect_endpoint_size() const;
  inline void clear_node_connect_endpoint();
  static const int kNodeConnectEndpointFieldNumber = 103;
  inline const ::std::string& node_connect_endpoint(int index) const;
  inline ::std::string* mutable_node_connect_endpoint(int index);
  inline void set_node_connect_endpoint(int index, const ::std::string& value);
  inline void set_node_connect_endpoint(int index, const char* value);
  inline void set_node_connect_endpoint(int index, const char* value, size_t size);
  inline ::std::string* add_node_connect_endpoint();
  inline void add_node_connect_endpoint(const ::std::string& value);
  inline void add_node_connect_endpoint(const char* value);
  inline void add_node_connect_endpoint(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& node_connect_endpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_node_connect_endpoint();

  // @@protoc_insertion_point(class_scope:artm.MasterComponentConfig)
 private:
  inline void set_has_disk_path();
  inline void clear_has_disk_path();
  inline void set_has_compact_batches();
  inline void clear_has_compact_batches();
  inline void set_has_cache_processor_output();
  inline void clear_has_cache_processor_output();
  inline void set_has_processors_count();
  inline void clear_has_processors_count();
  inline void set_has_processor_queue_max_size();
  inline void clear_has_processor_queue_max_size();
  inline void set_has_merger_queue_max_size();
  inline void clear_has_merger_queue_max_size();
  inline void set_has_modus_operandi();
  inline void clear_has_modus_operandi();
  inline void set_has_create_endpoint();
  inline void clear_has_create_endpoint();
  inline void set_has_connect_endpoint();
  inline void clear_has_connect_endpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* disk_path_;
  ::google::protobuf::RepeatedPtrField< ::artm::Stream > stream_;
  bool compact_batches_;
  bool cache_processor_output_;
  ::google::protobuf::int32 processors_count_;
  ::google::protobuf::int32 processor_queue_max_size_;
  ::google::protobuf::int32 merger_queue_max_size_;
  ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig > score_config_;
  ::std::string* create_endpoint_;
  ::std::string* connect_endpoint_;
  ::google::protobuf::RepeatedPtrField< ::std::string> node_connect_endpoint_;
  int modus_operandi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static MasterComponentConfig* default_instance_;
};
// -------------------------------------------------------------------

class MasterProxyConfig : public ::google::protobuf::Message {
 public:
  MasterProxyConfig();
  virtual ~MasterProxyConfig();

  MasterProxyConfig(const MasterProxyConfig& from);

  inline MasterProxyConfig& operator=(const MasterProxyConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterProxyConfig& default_instance();

  void Swap(MasterProxyConfig* other);

  // implements Message ----------------------------------------------

  MasterProxyConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterProxyConfig& from);
  void MergeFrom(const MasterProxyConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_connect_endpoint = 1;
  inline bool has_node_connect_endpoint() const;
  inline void clear_node_connect_endpoint();
  static const int kNodeConnectEndpointFieldNumber = 1;
  inline const ::std::string& node_connect_endpoint() const;
  inline void set_node_connect_endpoint(const ::std::string& value);
  inline void set_node_connect_endpoint(const char* value);
  inline void set_node_connect_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_node_connect_endpoint();
  inline ::std::string* release_node_connect_endpoint();
  inline void set_allocated_node_connect_endpoint(::std::string* node_connect_endpoint);

  // required .artm.MasterComponentConfig config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::artm::MasterComponentConfig& config() const;
  inline ::artm::MasterComponentConfig* mutable_config();
  inline ::artm::MasterComponentConfig* release_config();
  inline void set_allocated_config(::artm::MasterComponentConfig* config);

  // @@protoc_insertion_point(class_scope:artm.MasterProxyConfig)
 private:
  inline void set_has_node_connect_endpoint();
  inline void clear_has_node_connect_endpoint();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* node_connect_endpoint_;
  ::artm::MasterComponentConfig* config_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static MasterProxyConfig* default_instance_;
};
// -------------------------------------------------------------------

class ModelConfig : public ::google::protobuf::Message {
 public:
  ModelConfig();
  virtual ~ModelConfig();

  ModelConfig(const ModelConfig& from);

  inline ModelConfig& operator=(const ModelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelConfig& default_instance();

  void Swap(ModelConfig* other);

  // implements Message ----------------------------------------------

  ModelConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelConfig& from);
  void MergeFrom(const ModelConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "@model"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 topics_count = 2 [default = 32];
  inline bool has_topics_count() const;
  inline void clear_topics_count();
  static const int kTopicsCountFieldNumber = 2;
  inline ::google::protobuf::int32 topics_count() const;
  inline void set_topics_count(::google::protobuf::int32 value);

  // optional bool enabled = 3 [default = true];
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional int32 inner_iterations_count = 4 [default = 10];
  inline bool has_inner_iterations_count() const;
  inline void clear_inner_iterations_count();
  static const int kInnerIterationsCountFieldNumber = 4;
  inline ::google::protobuf::int32 inner_iterations_count() const;
  inline void set_inner_iterations_count(::google::protobuf::int32 value);

  // optional string field_name = 5 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 5;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 6 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 6;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // repeated string score_name = 7;
  inline int score_name_size() const;
  inline void clear_score_name();
  static const int kScoreNameFieldNumber = 7;
  inline const ::std::string& score_name(int index) const;
  inline ::std::string* mutable_score_name(int index);
  inline void set_score_name(int index, const ::std::string& value);
  inline void set_score_name(int index, const char* value);
  inline void set_score_name(int index, const char* value, size_t size);
  inline ::std::string* add_score_name();
  inline void add_score_name(const ::std::string& value);
  inline void add_score_name(const char* value);
  inline void add_score_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& score_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_score_name();

  // optional bool reuse_theta = 8 [default = false];
  inline bool has_reuse_theta() const;
  inline void clear_reuse_theta();
  static const int kReuseThetaFieldNumber = 8;
  inline bool reuse_theta() const;
  inline void set_reuse_theta(bool value);

  // repeated string regularizer_name = 9;
  inline int regularizer_name_size() const;
  inline void clear_regularizer_name();
  static const int kRegularizerNameFieldNumber = 9;
  inline const ::std::string& regularizer_name(int index) const;
  inline ::std::string* mutable_regularizer_name(int index);
  inline void set_regularizer_name(int index, const ::std::string& value);
  inline void set_regularizer_name(int index, const char* value);
  inline void set_regularizer_name(int index, const char* value, size_t size);
  inline ::std::string* add_regularizer_name();
  inline void add_regularizer_name(const ::std::string& value);
  inline void add_regularizer_name(const char* value);
  inline void add_regularizer_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& regularizer_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_regularizer_name();

  // repeated double regularizer_tau = 10;
  inline int regularizer_tau_size() const;
  inline void clear_regularizer_tau();
  static const int kRegularizerTauFieldNumber = 10;
  inline double regularizer_tau(int index) const;
  inline void set_regularizer_tau(int index, double value);
  inline void add_regularizer_tau(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      regularizer_tau() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_regularizer_tau();

  // @@protoc_insertion_point(class_scope:artm.ModelConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_topics_count();
  inline void clear_has_topics_count();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_inner_iterations_count();
  inline void clear_has_inner_iterations_count();
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();
  inline void set_has_reuse_theta();
  inline void clear_has_reuse_theta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::int32 topics_count_;
  ::google::protobuf::int32 inner_iterations_count_;
  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> score_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> regularizer_name_;
  ::google::protobuf::RepeatedField< double > regularizer_tau_;
  bool enabled_;
  bool reuse_theta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ModelConfig* default_instance_;
};
// -------------------------------------------------------------------

class RegularizerConfig : public ::google::protobuf::Message {
 public:
  RegularizerConfig();
  virtual ~RegularizerConfig();

  RegularizerConfig(const RegularizerConfig& from);

  inline RegularizerConfig& operator=(const RegularizerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegularizerConfig& default_instance();

  void Swap(RegularizerConfig* other);

  // implements Message ----------------------------------------------

  RegularizerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegularizerConfig& from);
  void MergeFrom(const RegularizerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegularizerConfig_Type Type;
  static const Type DirichletTheta = RegularizerConfig_Type_DirichletTheta;
  static const Type DirichletPhi = RegularizerConfig_Type_DirichletPhi;
  static const Type SmoothSparseTheta = RegularizerConfig_Type_SmoothSparseTheta;
  static const Type SmoothSparsePhi = RegularizerConfig_Type_SmoothSparsePhi;
  static const Type DecorrelatorPhi = RegularizerConfig_Type_DecorrelatorPhi;
  static inline bool Type_IsValid(int value) {
    return RegularizerConfig_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RegularizerConfig_Type_Type_MIN;
  static const Type Type_MAX =
    RegularizerConfig_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RegularizerConfig_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RegularizerConfig_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RegularizerConfig_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RegularizerConfig_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .artm.RegularizerConfig.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::RegularizerConfig_Type type() const;
  inline void set_type(::artm::RegularizerConfig_Type value);

  // optional bytes config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const void* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:artm.RegularizerConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* config_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegularizerConfig* default_instance_;
};
// -------------------------------------------------------------------

class DirichletThetaConfig : public ::google::protobuf::Message {
 public:
  DirichletThetaConfig();
  virtual ~DirichletThetaConfig();

  DirichletThetaConfig(const DirichletThetaConfig& from);

  inline DirichletThetaConfig& operator=(const DirichletThetaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirichletThetaConfig& default_instance();

  void Swap(DirichletThetaConfig* other);

  // implements Message ----------------------------------------------

  DirichletThetaConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirichletThetaConfig& from);
  void MergeFrom(const DirichletThetaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .artm.DoubleArray alpha = 1;
  inline int alpha_size() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  inline const ::artm::DoubleArray& alpha(int index) const;
  inline ::artm::DoubleArray* mutable_alpha(int index);
  inline ::artm::DoubleArray* add_alpha();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
      alpha() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
      mutable_alpha();

  // @@protoc_insertion_point(class_scope:artm.DirichletThetaConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray > alpha_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DirichletThetaConfig* default_instance_;
};
// -------------------------------------------------------------------

class DirichletPhiConfig : public ::google::protobuf::Message {
 public:
  DirichletPhiConfig();
  virtual ~DirichletPhiConfig();

  DirichletPhiConfig(const DirichletPhiConfig& from);

  inline DirichletPhiConfig& operator=(const DirichletPhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirichletPhiConfig& default_instance();

  void Swap(DirichletPhiConfig* other);

  // implements Message ----------------------------------------------

  DirichletPhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirichletPhiConfig& from);
  void MergeFrom(const DirichletPhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dictionary_name = 1;
  inline bool has_dictionary_name() const;
  inline void clear_dictionary_name();
  static const int kDictionaryNameFieldNumber = 1;
  inline const ::std::string& dictionary_name() const;
  inline void set_dictionary_name(const ::std::string& value);
  inline void set_dictionary_name(const char* value);
  inline void set_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_name();
  inline ::std::string* release_dictionary_name();
  inline void set_allocated_dictionary_name(::std::string* dictionary_name);

  // @@protoc_insertion_point(class_scope:artm.DirichletPhiConfig)
 private:
  inline void set_has_dictionary_name();
  inline void clear_has_dictionary_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dictionary_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DirichletPhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class SmoothSparseThetaConfig : public ::google::protobuf::Message {
 public:
  SmoothSparseThetaConfig();
  virtual ~SmoothSparseThetaConfig();

  SmoothSparseThetaConfig(const SmoothSparseThetaConfig& from);

  inline SmoothSparseThetaConfig& operator=(const SmoothSparseThetaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmoothSparseThetaConfig& default_instance();

  void Swap(SmoothSparseThetaConfig* other);

  // implements Message ----------------------------------------------

  SmoothSparseThetaConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmoothSparseThetaConfig& from);
  void MergeFrom(const SmoothSparseThetaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 background_topics_count = 1;
  inline bool has_background_topics_count() const;
  inline void clear_background_topics_count();
  static const int kBackgroundTopicsCountFieldNumber = 1;
  inline ::google::protobuf::int32 background_topics_count() const;
  inline void set_background_topics_count(::google::protobuf::int32 value);

  // repeated .artm.DoubleArray alpha = 2;
  inline int alpha_size() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 2;
  inline const ::artm::DoubleArray& alpha(int index) const;
  inline ::artm::DoubleArray* mutable_alpha(int index);
  inline ::artm::DoubleArray* add_alpha();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
      alpha() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
      mutable_alpha();

  // @@protoc_insertion_point(class_scope:artm.SmoothSparseThetaConfig)
 private:
  inline void set_has_background_topics_count();
  inline void clear_has_background_topics_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray > alpha_;
  ::google::protobuf::int32 background_topics_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SmoothSparseThetaConfig* default_instance_;
};
// -------------------------------------------------------------------

class SmoothSparsePhiConfig : public ::google::protobuf::Message {
 public:
  SmoothSparsePhiConfig();
  virtual ~SmoothSparsePhiConfig();

  SmoothSparsePhiConfig(const SmoothSparsePhiConfig& from);

  inline SmoothSparsePhiConfig& operator=(const SmoothSparsePhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmoothSparsePhiConfig& default_instance();

  void Swap(SmoothSparsePhiConfig* other);

  // implements Message ----------------------------------------------

  SmoothSparsePhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmoothSparsePhiConfig& from);
  void MergeFrom(const SmoothSparsePhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 background_topics_count = 1;
  inline bool has_background_topics_count() const;
  inline void clear_background_topics_count();
  static const int kBackgroundTopicsCountFieldNumber = 1;
  inline ::google::protobuf::int32 background_topics_count() const;
  inline void set_background_topics_count(::google::protobuf::int32 value);

  // optional .artm.BoolArray topics_to_regularize = 2;
  inline bool has_topics_to_regularize() const;
  inline void clear_topics_to_regularize();
  static const int kTopicsToRegularizeFieldNumber = 2;
  inline const ::artm::BoolArray& topics_to_regularize() const;
  inline ::artm::BoolArray* mutable_topics_to_regularize();
  inline ::artm::BoolArray* release_topics_to_regularize();
  inline void set_allocated_topics_to_regularize(::artm::BoolArray* topics_to_regularize);

  // optional string dictionary_name = 3;
  inline bool has_dictionary_name() const;
  inline void clear_dictionary_name();
  static const int kDictionaryNameFieldNumber = 3;
  inline const ::std::string& dictionary_name() const;
  inline void set_dictionary_name(const ::std::string& value);
  inline void set_dictionary_name(const char* value);
  inline void set_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_name();
  inline ::std::string* release_dictionary_name();
  inline void set_allocated_dictionary_name(::std::string* dictionary_name);

  // @@protoc_insertion_point(class_scope:artm.SmoothSparsePhiConfig)
 private:
  inline void set_has_background_topics_count();
  inline void clear_has_background_topics_count();
  inline void set_has_topics_to_regularize();
  inline void clear_has_topics_to_regularize();
  inline void set_has_dictionary_name();
  inline void clear_has_dictionary_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::artm::BoolArray* topics_to_regularize_;
  ::std::string* dictionary_name_;
  ::google::protobuf::int32 background_topics_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SmoothSparsePhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class DecorrelatorPhiConfig : public ::google::protobuf::Message {
 public:
  DecorrelatorPhiConfig();
  virtual ~DecorrelatorPhiConfig();

  DecorrelatorPhiConfig(const DecorrelatorPhiConfig& from);

  inline DecorrelatorPhiConfig& operator=(const DecorrelatorPhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecorrelatorPhiConfig& default_instance();

  void Swap(DecorrelatorPhiConfig* other);

  // implements Message ----------------------------------------------

  DecorrelatorPhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecorrelatorPhiConfig& from);
  void MergeFrom(const DecorrelatorPhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .artm.BoolArray topics_to_regularize = 1;
  inline bool has_topics_to_regularize() const;
  inline void clear_topics_to_regularize();
  static const int kTopicsToRegularizeFieldNumber = 1;
  inline const ::artm::BoolArray& topics_to_regularize() const;
  inline ::artm::BoolArray* mutable_topics_to_regularize();
  inline ::artm::BoolArray* release_topics_to_regularize();
  inline void set_allocated_topics_to_regularize(::artm::BoolArray* topics_to_regularize);

  // @@protoc_insertion_point(class_scope:artm.DecorrelatorPhiConfig)
 private:
  inline void set_has_topics_to_regularize();
  inline void clear_has_topics_to_regularize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::artm::BoolArray* topics_to_regularize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DecorrelatorPhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class DictionaryConfig : public ::google::protobuf::Message {
 public:
  DictionaryConfig();
  virtual ~DictionaryConfig();

  DictionaryConfig(const DictionaryConfig& from);

  inline DictionaryConfig& operator=(const DictionaryConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryConfig& default_instance();

  void Swap(DictionaryConfig* other);

  // implements Message ----------------------------------------------

  DictionaryConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DictionaryConfig& from);
  void MergeFrom(const DictionaryConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .artm.DictionaryEntry entry = 2;
  inline int entry_size() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline const ::artm::DictionaryEntry& entry(int index) const;
  inline ::artm::DictionaryEntry* mutable_entry(int index);
  inline ::artm::DictionaryEntry* add_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >&
      entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >*
      mutable_entry();

  // @@protoc_insertion_point(class_scope:artm.DictionaryConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry > entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DictionaryConfig* default_instance_;
};
// -------------------------------------------------------------------

class DictionaryEntry : public ::google::protobuf::Message {
 public:
  DictionaryEntry();
  virtual ~DictionaryEntry();

  DictionaryEntry(const DictionaryEntry& from);

  inline DictionaryEntry& operator=(const DictionaryEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryEntry& default_instance();

  void Swap(DictionaryEntry* other);

  // implements Message ----------------------------------------------

  DictionaryEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DictionaryEntry& from);
  void MergeFrom(const DictionaryEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key_token = 1;
  inline bool has_key_token() const;
  inline void clear_key_token();
  static const int kKeyTokenFieldNumber = 1;
  inline const ::std::string& key_token() const;
  inline void set_key_token(const ::std::string& value);
  inline void set_key_token(const char* value);
  inline void set_key_token(const char* value, size_t size);
  inline ::std::string* mutable_key_token();
  inline ::std::string* release_key_token();
  inline void set_allocated_key_token(::std::string* key_token);

  // optional float value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline float value() const;
  inline void set_value(float value);

  // repeated string value_tokens = 3;
  inline int value_tokens_size() const;
  inline void clear_value_tokens();
  static const int kValueTokensFieldNumber = 3;
  inline const ::std::string& value_tokens(int index) const;
  inline ::std::string* mutable_value_tokens(int index);
  inline void set_value_tokens(int index, const ::std::string& value);
  inline void set_value_tokens(int index, const char* value);
  inline void set_value_tokens(int index, const char* value, size_t size);
  inline ::std::string* add_value_tokens();
  inline void add_value_tokens(const ::std::string& value);
  inline void add_value_tokens(const char* value);
  inline void add_value_tokens(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value_tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value_tokens();

  // optional .artm.FloatArray values = 4;
  inline bool has_values() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 4;
  inline const ::artm::FloatArray& values() const;
  inline ::artm::FloatArray* mutable_values();
  inline ::artm::FloatArray* release_values();
  inline void set_allocated_values(::artm::FloatArray* values);

  // @@protoc_insertion_point(class_scope:artm.DictionaryEntry)
 private:
  inline void set_has_key_token();
  inline void clear_has_key_token();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_values();
  inline void clear_has_values();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_tokens_;
  ::artm::FloatArray* values_;
  float value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DictionaryEntry* default_instance_;
};
// -------------------------------------------------------------------

class DoubleArray : public ::google::protobuf::Message {
 public:
  DoubleArray();
  virtual ~DoubleArray();

  DoubleArray(const DoubleArray& from);

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleArray& default_instance();

  void Swap(DoubleArray* other);

  // implements Message ----------------------------------------------

  DoubleArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoubleArray& from);
  void MergeFrom(const DoubleArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 1 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.DoubleArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DoubleArray* default_instance_;
};
// -------------------------------------------------------------------

class FloatArray : public ::google::protobuf::Message {
 public:
  FloatArray();
  virtual ~FloatArray();

  FloatArray(const FloatArray& from);

  inline FloatArray& operator=(const FloatArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatArray& default_instance();

  void Swap(FloatArray* other);

  // implements Message ----------------------------------------------

  FloatArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloatArray& from);
  void MergeFrom(const FloatArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline float value(int index) const;
  inline void set_value(int index, float value);
  inline void add_value(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      value() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.FloatArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static FloatArray* default_instance_;
};
// -------------------------------------------------------------------

class BoolArray : public ::google::protobuf::Message {
 public:
  BoolArray();
  virtual ~BoolArray();

  BoolArray(const BoolArray& from);

  inline BoolArray& operator=(const BoolArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolArray& default_instance();

  void Swap(BoolArray* other);

  // implements Message ----------------------------------------------

  BoolArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoolArray& from);
  void MergeFrom(const BoolArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool value = 1 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline bool value(int index) const;
  inline void set_value(int index, bool value);
  inline void add_value(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      value() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.BoolArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< bool > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static BoolArray* default_instance_;
};
// -------------------------------------------------------------------

class ScoreConfig : public ::google::protobuf::Message {
 public:
  ScoreConfig();
  virtual ~ScoreConfig();

  ScoreConfig(const ScoreConfig& from);

  inline ScoreConfig& operator=(const ScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreConfig& default_instance();

  void Swap(ScoreConfig* other);

  // implements Message ----------------------------------------------

  ScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreConfig& from);
  void MergeFrom(const ScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScoreConfig_Type Type;
  static const Type Perplexity = ScoreConfig_Type_Perplexity;
  static inline bool Type_IsValid(int value) {
    return ScoreConfig_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ScoreConfig_Type_Type_MIN;
  static const Type Type_MAX =
    ScoreConfig_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ScoreConfig_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ScoreConfig_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ScoreConfig_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ScoreConfig_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .artm.ScoreConfig.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::ScoreConfig_Type type() const;
  inline void set_type(::artm::ScoreConfig_Type value);

  // optional bytes config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const void* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:artm.ScoreConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* config_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class ScoreData : public ::google::protobuf::Message {
 public:
  ScoreData();
  virtual ~ScoreData();

  ScoreData(const ScoreData& from);

  inline ScoreData& operator=(const ScoreData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreData& default_instance();

  void Swap(ScoreData* other);

  // implements Message ----------------------------------------------

  ScoreData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreData& from);
  void MergeFrom(const ScoreData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScoreData_Type Type;
  static const Type Perplexity = ScoreData_Type_Perplexity;
  static inline bool Type_IsValid(int value) {
    return ScoreData_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ScoreData_Type_Type_MIN;
  static const Type Type_MAX =
    ScoreData_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ScoreData_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ScoreData_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ScoreData_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ScoreData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .artm.ScoreData.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::ScoreData_Type type() const;
  inline void set_type(::artm::ScoreData_Type value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:artm.ScoreData)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ScoreData* default_instance_;
};
// -------------------------------------------------------------------

class PerplexityScoreConfig : public ::google::protobuf::Message {
 public:
  PerplexityScoreConfig();
  virtual ~PerplexityScoreConfig();

  PerplexityScoreConfig(const PerplexityScoreConfig& from);

  inline PerplexityScoreConfig& operator=(const PerplexityScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerplexityScoreConfig& default_instance();

  void Swap(PerplexityScoreConfig* other);

  // implements Message ----------------------------------------------

  PerplexityScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerplexityScoreConfig& from);
  void MergeFrom(const PerplexityScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string field_name = 1 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 2 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 2;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // @@protoc_insertion_point(class_scope:artm.PerplexityScoreConfig)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static PerplexityScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class PerplexityScore : public ::google::protobuf::Message {
 public:
  PerplexityScore();
  virtual ~PerplexityScore();

  PerplexityScore(const PerplexityScore& from);

  inline PerplexityScore& operator=(const PerplexityScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerplexityScore& default_instance();

  void Swap(PerplexityScore* other);

  // implements Message ----------------------------------------------

  PerplexityScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerplexityScore& from);
  void MergeFrom(const PerplexityScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // optional double raw = 2;
  inline bool has_raw() const;
  inline void clear_raw();
  static const int kRawFieldNumber = 2;
  inline double raw() const;
  inline void set_raw(double value);

  // optional double normalizer = 3;
  inline bool has_normalizer() const;
  inline void clear_normalizer();
  static const int kNormalizerFieldNumber = 3;
  inline double normalizer() const;
  inline void set_normalizer(double value);

  // optional int32 zero_words = 4;
  inline bool has_zero_words() const;
  inline void clear_zero_words();
  static const int kZeroWordsFieldNumber = 4;
  inline ::google::protobuf::int32 zero_words() const;
  inline void set_zero_words(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.PerplexityScore)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_raw();
  inline void clear_has_raw();
  inline void set_has_normalizer();
  inline void clear_has_normalizer();
  inline void set_has_zero_words();
  inline void clear_has_zero_words();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;
  double raw_;
  double normalizer_;
  ::google::protobuf::int32 zero_words_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static PerplexityScore* default_instance_;
};
// -------------------------------------------------------------------

class TopicModel_TopicModelInternals : public ::google::protobuf::Message {
 public:
  TopicModel_TopicModelInternals();
  virtual ~TopicModel_TopicModelInternals();

  TopicModel_TopicModelInternals(const TopicModel_TopicModelInternals& from);

  inline TopicModel_TopicModelInternals& operator=(const TopicModel_TopicModelInternals& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicModel_TopicModelInternals& default_instance();

  void Swap(TopicModel_TopicModelInternals* other);

  // implements Message ----------------------------------------------

  TopicModel_TopicModelInternals* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicModel_TopicModelInternals& from);
  void MergeFrom(const TopicModel_TopicModelInternals& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .artm.FloatArray n_wt = 1;
  inline int n_wt_size() const;
  inline void clear_n_wt();
  static const int kNWtFieldNumber = 1;
  inline const ::artm::FloatArray& n_wt(int index) const;
  inline ::artm::FloatArray* mutable_n_wt(int index);
  inline ::artm::FloatArray* add_n_wt();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      n_wt() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_n_wt();

  // repeated .artm.FloatArray r_wt = 2;
  inline int r_wt_size() const;
  inline void clear_r_wt();
  static const int kRWtFieldNumber = 2;
  inline const ::artm::FloatArray& r_wt(int index) const;
  inline ::artm::FloatArray* mutable_r_wt(int index);
  inline ::artm::FloatArray* add_r_wt();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      r_wt() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_r_wt();

  // optional .artm.FloatArray n_t = 3;
  inline bool has_n_t() const;
  inline void clear_n_t();
  static const int kNTFieldNumber = 3;
  inline const ::artm::FloatArray& n_t() const;
  inline ::artm::FloatArray* mutable_n_t();
  inline ::artm::FloatArray* release_n_t();
  inline void set_allocated_n_t(::artm::FloatArray* n_t);

  // @@protoc_insertion_point(class_scope:artm.TopicModel.TopicModelInternals)
 private:
  inline void set_has_n_t();
  inline void clear_has_n_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > n_wt_;
  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > r_wt_;
  ::artm::FloatArray* n_t_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopicModel_TopicModelInternals* default_instance_;
};
// -------------------------------------------------------------------

class TopicModel : public ::google::protobuf::Message {
 public:
  TopicModel();
  virtual ~TopicModel();

  TopicModel(const TopicModel& from);

  inline TopicModel& operator=(const TopicModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicModel& default_instance();

  void Swap(TopicModel* other);

  // implements Message ----------------------------------------------

  TopicModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicModel& from);
  void MergeFrom(const TopicModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TopicModel_TopicModelInternals TopicModelInternals;

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "@model"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 topics_count = 2;
  inline bool has_topics_count() const;
  inline void clear_topics_count();
  static const int kTopicsCountFieldNumber = 2;
  inline ::google::protobuf::int32 topics_count() const;
  inline void set_topics_count(::google::protobuf::int32 value);

  // repeated string token = 3;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated .artm.FloatArray token_weights = 4;
  inline int token_weights_size() const;
  inline void clear_token_weights();
  static const int kTokenWeightsFieldNumber = 4;
  inline const ::artm::FloatArray& token_weights(int index) const;
  inline ::artm::FloatArray* mutable_token_weights(int index);
  inline ::artm::FloatArray* add_token_weights();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      token_weights() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_token_weights();

  // optional bytes internals = 5;
  inline bool has_internals() const;
  inline void clear_internals();
  static const int kInternalsFieldNumber = 5;
  inline const ::std::string& internals() const;
  inline void set_internals(const ::std::string& value);
  inline void set_internals(const char* value);
  inline void set_internals(const void* value, size_t size);
  inline ::std::string* mutable_internals();
  inline ::std::string* release_internals();
  inline void set_allocated_internals(::std::string* internals);

  // @@protoc_insertion_point(class_scope:artm.TopicModel)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_topics_count();
  inline void clear_has_topics_count();
  inline void set_has_internals();
  inline void clear_has_internals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > token_weights_;
  ::std::string* internals_;
  ::google::protobuf::int32 topics_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopicModel* default_instance_;
};
// -------------------------------------------------------------------

class ThetaMatrix : public ::google::protobuf::Message {
 public:
  ThetaMatrix();
  virtual ~ThetaMatrix();

  ThetaMatrix(const ThetaMatrix& from);

  inline ThetaMatrix& operator=(const ThetaMatrix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThetaMatrix& default_instance();

  void Swap(ThetaMatrix* other);

  // implements Message ----------------------------------------------

  ThetaMatrix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThetaMatrix& from);
  void MergeFrom(const ThetaMatrix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model_name = 1 [default = "@model"];
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // repeated int32 item_id = 2;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::int32 value);
  inline void add_item_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_id();

  // repeated .artm.FloatArray item_weights = 3;
  inline int item_weights_size() const;
  inline void clear_item_weights();
  static const int kItemWeightsFieldNumber = 3;
  inline const ::artm::FloatArray& item_weights(int index) const;
  inline ::artm::FloatArray* mutable_item_weights(int index);
  inline ::artm::FloatArray* add_item_weights();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      item_weights() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_item_weights();

  // @@protoc_insertion_point(class_scope:artm.ThetaMatrix)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  static ::std::string* _default_model_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_id_;
  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > item_weights_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ThetaMatrix* default_instance_;
};
// -------------------------------------------------------------------

class NodeControllerConfig : public ::google::protobuf::Message {
 public:
  NodeControllerConfig();
  virtual ~NodeControllerConfig();

  NodeControllerConfig(const NodeControllerConfig& from);

  inline NodeControllerConfig& operator=(const NodeControllerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeControllerConfig& default_instance();

  void Swap(NodeControllerConfig* other);

  // implements Message ----------------------------------------------

  NodeControllerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeControllerConfig& from);
  void MergeFrom(const NodeControllerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string create_endpoint = 1;
  inline bool has_create_endpoint() const;
  inline void clear_create_endpoint();
  static const int kCreateEndpointFieldNumber = 1;
  inline const ::std::string& create_endpoint() const;
  inline void set_create_endpoint(const ::std::string& value);
  inline void set_create_endpoint(const char* value);
  inline void set_create_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_create_endpoint();
  inline ::std::string* release_create_endpoint();
  inline void set_allocated_create_endpoint(::std::string* create_endpoint);

  // @@protoc_insertion_point(class_scope:artm.NodeControllerConfig)
 private:
  inline void set_has_create_endpoint();
  inline void clear_has_create_endpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* create_endpoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static NodeControllerConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// Item

// optional int32 id = 1;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Item::id() const {
  return id_;
}
inline void Item::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .artm.Field field = 2;
inline int Item::field_size() const {
  return field_.size();
}
inline void Item::clear_field() {
  field_.Clear();
}
inline const ::artm::Field& Item::field(int index) const {
  return field_.Get(index);
}
inline ::artm::Field* Item::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::artm::Field* Item::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Field >&
Item::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Field >*
Item::mutable_field() {
  return &field_;
}

// -------------------------------------------------------------------

// Field

// optional string name = 1 [default = "@body"];
inline bool Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Field::name() const {
  return *name_;
}
inline void Field::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Field::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Field::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated int32 token_id = 2;
inline int Field::token_id_size() const {
  return token_id_.size();
}
inline void Field::clear_token_id() {
  token_id_.Clear();
}
inline ::google::protobuf::int32 Field::token_id(int index) const {
  return token_id_.Get(index);
}
inline void Field::set_token_id(int index, ::google::protobuf::int32 value) {
  token_id_.Set(index, value);
}
inline void Field::add_token_id(::google::protobuf::int32 value) {
  token_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Field::token_id() const {
  return token_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Field::mutable_token_id() {
  return &token_id_;
}

// repeated int32 token_count = 3;
inline int Field::token_count_size() const {
  return token_count_.size();
}
inline void Field::clear_token_count() {
  token_count_.Clear();
}
inline ::google::protobuf::int32 Field::token_count(int index) const {
  return token_count_.Get(index);
}
inline void Field::set_token_count(int index, ::google::protobuf::int32 value) {
  token_count_.Set(index, value);
}
inline void Field::add_token_count(::google::protobuf::int32 value) {
  token_count_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Field::token_count() const {
  return token_count_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Field::mutable_token_count() {
  return &token_count_;
}

// -------------------------------------------------------------------

// Batch

// repeated string token = 1;
inline int Batch::token_size() const {
  return token_.size();
}
inline void Batch::clear_token() {
  token_.Clear();
}
inline const ::std::string& Batch::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* Batch::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void Batch::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void Batch::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void Batch::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Batch::add_token() {
  return token_.Add();
}
inline void Batch::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void Batch::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void Batch::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Batch::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Batch::mutable_token() {
  return &token_;
}

// repeated .artm.Item item = 2;
inline int Batch::item_size() const {
  return item_.size();
}
inline void Batch::clear_item() {
  item_.Clear();
}
inline const ::artm::Item& Batch::item(int index) const {
  return item_.Get(index);
}
inline ::artm::Item* Batch::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::artm::Item* Batch::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Item >&
Batch::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Item >*
Batch::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// Stream

// optional .artm.Stream.Type type = 1 [default = Global];
inline bool Stream::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::Stream_Type Stream::type() const {
  return static_cast< ::artm::Stream_Type >(type_);
}
inline void Stream::set_type(::artm::Stream_Type value) {
  assert(::artm::Stream_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 2 [default = "@global"];
inline bool Stream::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Stream::name() const {
  return *name_;
}
inline void Stream::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stream::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stream::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stream::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Stream::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Stream::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// optional int32 modulus = 3;
inline bool Stream::has_modulus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stream::set_has_modulus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stream::clear_has_modulus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stream::clear_modulus() {
  modulus_ = 0;
  clear_has_modulus();
}
inline ::google::protobuf::int32 Stream::modulus() const {
  return modulus_;
}
inline void Stream::set_modulus(::google::protobuf::int32 value) {
  set_has_modulus();
  modulus_ = value;
}

// repeated int32 residuals = 4;
inline int Stream::residuals_size() const {
  return residuals_.size();
}
inline void Stream::clear_residuals() {
  residuals_.Clear();
}
inline ::google::protobuf::int32 Stream::residuals(int index) const {
  return residuals_.Get(index);
}
inline void Stream::set_residuals(int index, ::google::protobuf::int32 value) {
  residuals_.Set(index, value);
}
inline void Stream::add_residuals(::google::protobuf::int32 value) {
  residuals_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Stream::residuals() const {
  return residuals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Stream::mutable_residuals() {
  return &residuals_;
}

// -------------------------------------------------------------------

// MasterComponentConfig

// optional string disk_path = 1;
inline bool MasterComponentConfig::has_disk_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterComponentConfig::set_has_disk_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterComponentConfig::clear_has_disk_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterComponentConfig::clear_disk_path() {
  if (disk_path_ != &::google::protobuf::internal::kEmptyString) {
    disk_path_->clear();
  }
  clear_has_disk_path();
}
inline const ::std::string& MasterComponentConfig::disk_path() const {
  return *disk_path_;
}
inline void MasterComponentConfig::set_disk_path(const ::std::string& value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void MasterComponentConfig::set_disk_path(const char* value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void MasterComponentConfig::set_disk_path(const char* value, size_t size) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterComponentConfig::mutable_disk_path() {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    disk_path_ = new ::std::string;
  }
  return disk_path_;
}
inline ::std::string* MasterComponentConfig::release_disk_path() {
  clear_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disk_path_;
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterComponentConfig::set_allocated_disk_path(::std::string* disk_path) {
  if (disk_path_ != &::google::protobuf::internal::kEmptyString) {
    delete disk_path_;
  }
  if (disk_path) {
    set_has_disk_path();
    disk_path_ = disk_path;
  } else {
    clear_has_disk_path();
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .artm.Stream stream = 2;
inline int MasterComponentConfig::stream_size() const {
  return stream_.size();
}
inline void MasterComponentConfig::clear_stream() {
  stream_.Clear();
}
inline const ::artm::Stream& MasterComponentConfig::stream(int index) const {
  return stream_.Get(index);
}
inline ::artm::Stream* MasterComponentConfig::mutable_stream(int index) {
  return stream_.Mutable(index);
}
inline ::artm::Stream* MasterComponentConfig::add_stream() {
  return stream_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Stream >&
MasterComponentConfig::stream() const {
  return stream_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Stream >*
MasterComponentConfig::mutable_stream() {
  return &stream_;
}

// optional bool compact_batches = 3 [default = true];
inline bool MasterComponentConfig::has_compact_batches() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterComponentConfig::set_has_compact_batches() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterComponentConfig::clear_has_compact_batches() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterComponentConfig::clear_compact_batches() {
  compact_batches_ = true;
  clear_has_compact_batches();
}
inline bool MasterComponentConfig::compact_batches() const {
  return compact_batches_;
}
inline void MasterComponentConfig::set_compact_batches(bool value) {
  set_has_compact_batches();
  compact_batches_ = value;
}

// optional bool cache_processor_output = 4 [default = false];
inline bool MasterComponentConfig::has_cache_processor_output() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterComponentConfig::set_has_cache_processor_output() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterComponentConfig::clear_has_cache_processor_output() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterComponentConfig::clear_cache_processor_output() {
  cache_processor_output_ = false;
  clear_has_cache_processor_output();
}
inline bool MasterComponentConfig::cache_processor_output() const {
  return cache_processor_output_;
}
inline void MasterComponentConfig::set_cache_processor_output(bool value) {
  set_has_cache_processor_output();
  cache_processor_output_ = value;
}

// optional int32 processors_count = 5 [default = 1];
inline bool MasterComponentConfig::has_processors_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MasterComponentConfig::set_has_processors_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MasterComponentConfig::clear_has_processors_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MasterComponentConfig::clear_processors_count() {
  processors_count_ = 1;
  clear_has_processors_count();
}
inline ::google::protobuf::int32 MasterComponentConfig::processors_count() const {
  return processors_count_;
}
inline void MasterComponentConfig::set_processors_count(::google::protobuf::int32 value) {
  set_has_processors_count();
  processors_count_ = value;
}

// optional int32 processor_queue_max_size = 6 [default = 10];
inline bool MasterComponentConfig::has_processor_queue_max_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MasterComponentConfig::set_has_processor_queue_max_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MasterComponentConfig::clear_has_processor_queue_max_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MasterComponentConfig::clear_processor_queue_max_size() {
  processor_queue_max_size_ = 10;
  clear_has_processor_queue_max_size();
}
inline ::google::protobuf::int32 MasterComponentConfig::processor_queue_max_size() const {
  return processor_queue_max_size_;
}
inline void MasterComponentConfig::set_processor_queue_max_size(::google::protobuf::int32 value) {
  set_has_processor_queue_max_size();
  processor_queue_max_size_ = value;
}

// optional int32 merger_queue_max_size = 7 [default = 10];
inline bool MasterComponentConfig::has_merger_queue_max_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MasterComponentConfig::set_has_merger_queue_max_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MasterComponentConfig::clear_has_merger_queue_max_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MasterComponentConfig::clear_merger_queue_max_size() {
  merger_queue_max_size_ = 10;
  clear_has_merger_queue_max_size();
}
inline ::google::protobuf::int32 MasterComponentConfig::merger_queue_max_size() const {
  return merger_queue_max_size_;
}
inline void MasterComponentConfig::set_merger_queue_max_size(::google::protobuf::int32 value) {
  set_has_merger_queue_max_size();
  merger_queue_max_size_ = value;
}

// repeated .artm.ScoreConfig score_config = 8;
inline int MasterComponentConfig::score_config_size() const {
  return score_config_.size();
}
inline void MasterComponentConfig::clear_score_config() {
  score_config_.Clear();
}
inline const ::artm::ScoreConfig& MasterComponentConfig::score_config(int index) const {
  return score_config_.Get(index);
}
inline ::artm::ScoreConfig* MasterComponentConfig::mutable_score_config(int index) {
  return score_config_.Mutable(index);
}
inline ::artm::ScoreConfig* MasterComponentConfig::add_score_config() {
  return score_config_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >&
MasterComponentConfig::score_config() const {
  return score_config_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >*
MasterComponentConfig::mutable_score_config() {
  return &score_config_;
}

// optional .artm.MasterComponentConfig.ModusOperandi modus_operandi = 100 [default = Local];
inline bool MasterComponentConfig::has_modus_operandi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MasterComponentConfig::set_has_modus_operandi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MasterComponentConfig::clear_has_modus_operandi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MasterComponentConfig::clear_modus_operandi() {
  modus_operandi_ = 0;
  clear_has_modus_operandi();
}
inline ::artm::MasterComponentConfig_ModusOperandi MasterComponentConfig::modus_operandi() const {
  return static_cast< ::artm::MasterComponentConfig_ModusOperandi >(modus_operandi_);
}
inline void MasterComponentConfig::set_modus_operandi(::artm::MasterComponentConfig_ModusOperandi value) {
  assert(::artm::MasterComponentConfig_ModusOperandi_IsValid(value));
  set_has_modus_operandi();
  modus_operandi_ = value;
}

// optional string create_endpoint = 101;
inline bool MasterComponentConfig::has_create_endpoint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MasterComponentConfig::set_has_create_endpoint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MasterComponentConfig::clear_has_create_endpoint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MasterComponentConfig::clear_create_endpoint() {
  if (create_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    create_endpoint_->clear();
  }
  clear_has_create_endpoint();
}
inline const ::std::string& MasterComponentConfig::create_endpoint() const {
  return *create_endpoint_;
}
inline void MasterComponentConfig::set_create_endpoint(const ::std::string& value) {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  create_endpoint_->assign(value);
}
inline void MasterComponentConfig::set_create_endpoint(const char* value) {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  create_endpoint_->assign(value);
}
inline void MasterComponentConfig::set_create_endpoint(const char* value, size_t size) {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  create_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterComponentConfig::mutable_create_endpoint() {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  return create_endpoint_;
}
inline ::std::string* MasterComponentConfig::release_create_endpoint() {
  clear_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_endpoint_;
    create_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterComponentConfig::set_allocated_create_endpoint(::std::string* create_endpoint) {
  if (create_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete create_endpoint_;
  }
  if (create_endpoint) {
    set_has_create_endpoint();
    create_endpoint_ = create_endpoint;
  } else {
    clear_has_create_endpoint();
    create_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connect_endpoint = 102;
inline bool MasterComponentConfig::has_connect_endpoint() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MasterComponentConfig::set_has_connect_endpoint() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MasterComponentConfig::clear_has_connect_endpoint() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MasterComponentConfig::clear_connect_endpoint() {
  if (connect_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    connect_endpoint_->clear();
  }
  clear_has_connect_endpoint();
}
inline const ::std::string& MasterComponentConfig::connect_endpoint() const {
  return *connect_endpoint_;
}
inline void MasterComponentConfig::set_connect_endpoint(const ::std::string& value) {
  set_has_connect_endpoint();
  if (connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    connect_endpoint_ = new ::std::string;
  }
  connect_endpoint_->assign(value);
}
inline void MasterComponentConfig::set_connect_endpoint(const char* value) {
  set_has_connect_endpoint();
  if (connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    connect_endpoint_ = new ::std::string;
  }
  connect_endpoint_->assign(value);
}
inline void MasterComponentConfig::set_connect_endpoint(const char* value, size_t size) {
  set_has_connect_endpoint();
  if (connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    connect_endpoint_ = new ::std::string;
  }
  connect_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterComponentConfig::mutable_connect_endpoint() {
  set_has_connect_endpoint();
  if (connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    connect_endpoint_ = new ::std::string;
  }
  return connect_endpoint_;
}
inline ::std::string* MasterComponentConfig::release_connect_endpoint() {
  clear_has_connect_endpoint();
  if (connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connect_endpoint_;
    connect_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterComponentConfig::set_allocated_connect_endpoint(::std::string* connect_endpoint) {
  if (connect_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete connect_endpoint_;
  }
  if (connect_endpoint) {
    set_has_connect_endpoint();
    connect_endpoint_ = connect_endpoint;
  } else {
    clear_has_connect_endpoint();
    connect_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string node_connect_endpoint = 103;
inline int MasterComponentConfig::node_connect_endpoint_size() const {
  return node_connect_endpoint_.size();
}
inline void MasterComponentConfig::clear_node_connect_endpoint() {
  node_connect_endpoint_.Clear();
}
inline const ::std::string& MasterComponentConfig::node_connect_endpoint(int index) const {
  return node_connect_endpoint_.Get(index);
}
inline ::std::string* MasterComponentConfig::mutable_node_connect_endpoint(int index) {
  return node_connect_endpoint_.Mutable(index);
}
inline void MasterComponentConfig::set_node_connect_endpoint(int index, const ::std::string& value) {
  node_connect_endpoint_.Mutable(index)->assign(value);
}
inline void MasterComponentConfig::set_node_connect_endpoint(int index, const char* value) {
  node_connect_endpoint_.Mutable(index)->assign(value);
}
inline void MasterComponentConfig::set_node_connect_endpoint(int index, const char* value, size_t size) {
  node_connect_endpoint_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterComponentConfig::add_node_connect_endpoint() {
  return node_connect_endpoint_.Add();
}
inline void MasterComponentConfig::add_node_connect_endpoint(const ::std::string& value) {
  node_connect_endpoint_.Add()->assign(value);
}
inline void MasterComponentConfig::add_node_connect_endpoint(const char* value) {
  node_connect_endpoint_.Add()->assign(value);
}
inline void MasterComponentConfig::add_node_connect_endpoint(const char* value, size_t size) {
  node_connect_endpoint_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MasterComponentConfig::node_connect_endpoint() const {
  return node_connect_endpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MasterComponentConfig::mutable_node_connect_endpoint() {
  return &node_connect_endpoint_;
}

// -------------------------------------------------------------------

// MasterProxyConfig

// required string node_connect_endpoint = 1;
inline bool MasterProxyConfig::has_node_connect_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterProxyConfig::set_has_node_connect_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterProxyConfig::clear_has_node_connect_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterProxyConfig::clear_node_connect_endpoint() {
  if (node_connect_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    node_connect_endpoint_->clear();
  }
  clear_has_node_connect_endpoint();
}
inline const ::std::string& MasterProxyConfig::node_connect_endpoint() const {
  return *node_connect_endpoint_;
}
inline void MasterProxyConfig::set_node_connect_endpoint(const ::std::string& value) {
  set_has_node_connect_endpoint();
  if (node_connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    node_connect_endpoint_ = new ::std::string;
  }
  node_connect_endpoint_->assign(value);
}
inline void MasterProxyConfig::set_node_connect_endpoint(const char* value) {
  set_has_node_connect_endpoint();
  if (node_connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    node_connect_endpoint_ = new ::std::string;
  }
  node_connect_endpoint_->assign(value);
}
inline void MasterProxyConfig::set_node_connect_endpoint(const char* value, size_t size) {
  set_has_node_connect_endpoint();
  if (node_connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    node_connect_endpoint_ = new ::std::string;
  }
  node_connect_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterProxyConfig::mutable_node_connect_endpoint() {
  set_has_node_connect_endpoint();
  if (node_connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    node_connect_endpoint_ = new ::std::string;
  }
  return node_connect_endpoint_;
}
inline ::std::string* MasterProxyConfig::release_node_connect_endpoint() {
  clear_has_node_connect_endpoint();
  if (node_connect_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_connect_endpoint_;
    node_connect_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterProxyConfig::set_allocated_node_connect_endpoint(::std::string* node_connect_endpoint) {
  if (node_connect_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete node_connect_endpoint_;
  }
  if (node_connect_endpoint) {
    set_has_node_connect_endpoint();
    node_connect_endpoint_ = node_connect_endpoint;
  } else {
    clear_has_node_connect_endpoint();
    node_connect_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .artm.MasterComponentConfig config = 2;
inline bool MasterProxyConfig::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterProxyConfig::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterProxyConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterProxyConfig::clear_config() {
  if (config_ != NULL) config_->::artm::MasterComponentConfig::Clear();
  clear_has_config();
}
inline const ::artm::MasterComponentConfig& MasterProxyConfig::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::artm::MasterComponentConfig* MasterProxyConfig::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::artm::MasterComponentConfig;
  return config_;
}
inline ::artm::MasterComponentConfig* MasterProxyConfig::release_config() {
  clear_has_config();
  ::artm::MasterComponentConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void MasterProxyConfig::set_allocated_config(::artm::MasterComponentConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
}

// -------------------------------------------------------------------

// ModelConfig

// optional string name = 1 [default = "@model"];
inline bool ModelConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelConfig::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& ModelConfig::name() const {
  return *name_;
}
inline void ModelConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* ModelConfig::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// optional int32 topics_count = 2 [default = 32];
inline bool ModelConfig::has_topics_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelConfig::set_has_topics_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelConfig::clear_has_topics_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelConfig::clear_topics_count() {
  topics_count_ = 32;
  clear_has_topics_count();
}
inline ::google::protobuf::int32 ModelConfig::topics_count() const {
  return topics_count_;
}
inline void ModelConfig::set_topics_count(::google::protobuf::int32 value) {
  set_has_topics_count();
  topics_count_ = value;
}

// optional bool enabled = 3 [default = true];
inline bool ModelConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool ModelConfig::enabled() const {
  return enabled_;
}
inline void ModelConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional int32 inner_iterations_count = 4 [default = 10];
inline bool ModelConfig::has_inner_iterations_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelConfig::set_has_inner_iterations_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelConfig::clear_has_inner_iterations_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelConfig::clear_inner_iterations_count() {
  inner_iterations_count_ = 10;
  clear_has_inner_iterations_count();
}
inline ::google::protobuf::int32 ModelConfig::inner_iterations_count() const {
  return inner_iterations_count_;
}
inline void ModelConfig::set_inner_iterations_count(::google::protobuf::int32 value) {
  set_has_inner_iterations_count();
  inner_iterations_count_ = value;
}

// optional string field_name = 5 [default = "@body"];
inline bool ModelConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& ModelConfig::field_name() const {
  return *field_name_;
}
inline void ModelConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ModelConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ModelConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* ModelConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 6 [default = "@global"];
inline bool ModelConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModelConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModelConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModelConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& ModelConfig::stream_name() const {
  return *stream_name_;
}
inline void ModelConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ModelConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ModelConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* ModelConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// repeated string score_name = 7;
inline int ModelConfig::score_name_size() const {
  return score_name_.size();
}
inline void ModelConfig::clear_score_name() {
  score_name_.Clear();
}
inline const ::std::string& ModelConfig::score_name(int index) const {
  return score_name_.Get(index);
}
inline ::std::string* ModelConfig::mutable_score_name(int index) {
  return score_name_.Mutable(index);
}
inline void ModelConfig::set_score_name(int index, const ::std::string& value) {
  score_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_score_name(int index, const char* value) {
  score_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_score_name(int index, const char* value, size_t size) {
  score_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::add_score_name() {
  return score_name_.Add();
}
inline void ModelConfig::add_score_name(const ::std::string& value) {
  score_name_.Add()->assign(value);
}
inline void ModelConfig::add_score_name(const char* value) {
  score_name_.Add()->assign(value);
}
inline void ModelConfig::add_score_name(const char* value, size_t size) {
  score_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelConfig::score_name() const {
  return score_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelConfig::mutable_score_name() {
  return &score_name_;
}

// optional bool reuse_theta = 8 [default = false];
inline bool ModelConfig::has_reuse_theta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ModelConfig::set_has_reuse_theta() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ModelConfig::clear_has_reuse_theta() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ModelConfig::clear_reuse_theta() {
  reuse_theta_ = false;
  clear_has_reuse_theta();
}
inline bool ModelConfig::reuse_theta() const {
  return reuse_theta_;
}
inline void ModelConfig::set_reuse_theta(bool value) {
  set_has_reuse_theta();
  reuse_theta_ = value;
}

// repeated string regularizer_name = 9;
inline int ModelConfig::regularizer_name_size() const {
  return regularizer_name_.size();
}
inline void ModelConfig::clear_regularizer_name() {
  regularizer_name_.Clear();
}
inline const ::std::string& ModelConfig::regularizer_name(int index) const {
  return regularizer_name_.Get(index);
}
inline ::std::string* ModelConfig::mutable_regularizer_name(int index) {
  return regularizer_name_.Mutable(index);
}
inline void ModelConfig::set_regularizer_name(int index, const ::std::string& value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_regularizer_name(int index, const char* value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_regularizer_name(int index, const char* value, size_t size) {
  regularizer_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::add_regularizer_name() {
  return regularizer_name_.Add();
}
inline void ModelConfig::add_regularizer_name(const ::std::string& value) {
  regularizer_name_.Add()->assign(value);
}
inline void ModelConfig::add_regularizer_name(const char* value) {
  regularizer_name_.Add()->assign(value);
}
inline void ModelConfig::add_regularizer_name(const char* value, size_t size) {
  regularizer_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelConfig::regularizer_name() const {
  return regularizer_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelConfig::mutable_regularizer_name() {
  return &regularizer_name_;
}

// repeated double regularizer_tau = 10;
inline int ModelConfig::regularizer_tau_size() const {
  return regularizer_tau_.size();
}
inline void ModelConfig::clear_regularizer_tau() {
  regularizer_tau_.Clear();
}
inline double ModelConfig::regularizer_tau(int index) const {
  return regularizer_tau_.Get(index);
}
inline void ModelConfig::set_regularizer_tau(int index, double value) {
  regularizer_tau_.Set(index, value);
}
inline void ModelConfig::add_regularizer_tau(double value) {
  regularizer_tau_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ModelConfig::regularizer_tau() const {
  return regularizer_tau_;
}
inline ::google::protobuf::RepeatedField< double >*
ModelConfig::mutable_regularizer_tau() {
  return &regularizer_tau_;
}

// -------------------------------------------------------------------

// RegularizerConfig

// optional string name = 1;
inline bool RegularizerConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegularizerConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegularizerConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegularizerConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegularizerConfig::name() const {
  return *name_;
}
inline void RegularizerConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegularizerConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegularizerConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .artm.RegularizerConfig.Type type = 2;
inline bool RegularizerConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegularizerConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegularizerConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegularizerConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::RegularizerConfig_Type RegularizerConfig::type() const {
  return static_cast< ::artm::RegularizerConfig_Type >(type_);
}
inline void RegularizerConfig::set_type(::artm::RegularizerConfig_Type value) {
  assert(::artm::RegularizerConfig_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes config = 3;
inline bool RegularizerConfig::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegularizerConfig::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegularizerConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegularizerConfig::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& RegularizerConfig::config() const {
  return *config_;
}
inline void RegularizerConfig::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void RegularizerConfig::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void RegularizerConfig::set_config(const void* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerConfig::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* RegularizerConfig::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegularizerConfig::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DirichletThetaConfig

// repeated .artm.DoubleArray alpha = 1;
inline int DirichletThetaConfig::alpha_size() const {
  return alpha_.size();
}
inline void DirichletThetaConfig::clear_alpha() {
  alpha_.Clear();
}
inline const ::artm::DoubleArray& DirichletThetaConfig::alpha(int index) const {
  return alpha_.Get(index);
}
inline ::artm::DoubleArray* DirichletThetaConfig::mutable_alpha(int index) {
  return alpha_.Mutable(index);
}
inline ::artm::DoubleArray* DirichletThetaConfig::add_alpha() {
  return alpha_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
DirichletThetaConfig::alpha() const {
  return alpha_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
DirichletThetaConfig::mutable_alpha() {
  return &alpha_;
}

// -------------------------------------------------------------------

// DirichletPhiConfig

// optional string dictionary_name = 1;
inline bool DirichletPhiConfig::has_dictionary_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirichletPhiConfig::set_has_dictionary_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirichletPhiConfig::clear_has_dictionary_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirichletPhiConfig::clear_dictionary_name() {
  if (dictionary_name_ != &::google::protobuf::internal::kEmptyString) {
    dictionary_name_->clear();
  }
  clear_has_dictionary_name();
}
inline const ::std::string& DirichletPhiConfig::dictionary_name() const {
  return *dictionary_name_;
}
inline void DirichletPhiConfig::set_dictionary_name(const ::std::string& value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void DirichletPhiConfig::set_dictionary_name(const char* value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void DirichletPhiConfig::set_dictionary_name(const char* value, size_t size) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirichletPhiConfig::mutable_dictionary_name() {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  return dictionary_name_;
}
inline ::std::string* DirichletPhiConfig::release_dictionary_name() {
  clear_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_name_;
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirichletPhiConfig::set_allocated_dictionary_name(::std::string* dictionary_name) {
  if (dictionary_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dictionary_name_;
  }
  if (dictionary_name) {
    set_has_dictionary_name();
    dictionary_name_ = dictionary_name;
  } else {
    clear_has_dictionary_name();
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SmoothSparseThetaConfig

// optional int32 background_topics_count = 1;
inline bool SmoothSparseThetaConfig::has_background_topics_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmoothSparseThetaConfig::set_has_background_topics_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmoothSparseThetaConfig::clear_has_background_topics_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmoothSparseThetaConfig::clear_background_topics_count() {
  background_topics_count_ = 0;
  clear_has_background_topics_count();
}
inline ::google::protobuf::int32 SmoothSparseThetaConfig::background_topics_count() const {
  return background_topics_count_;
}
inline void SmoothSparseThetaConfig::set_background_topics_count(::google::protobuf::int32 value) {
  set_has_background_topics_count();
  background_topics_count_ = value;
}

// repeated .artm.DoubleArray alpha = 2;
inline int SmoothSparseThetaConfig::alpha_size() const {
  return alpha_.size();
}
inline void SmoothSparseThetaConfig::clear_alpha() {
  alpha_.Clear();
}
inline const ::artm::DoubleArray& SmoothSparseThetaConfig::alpha(int index) const {
  return alpha_.Get(index);
}
inline ::artm::DoubleArray* SmoothSparseThetaConfig::mutable_alpha(int index) {
  return alpha_.Mutable(index);
}
inline ::artm::DoubleArray* SmoothSparseThetaConfig::add_alpha() {
  return alpha_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >&
SmoothSparseThetaConfig::alpha() const {
  return alpha_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DoubleArray >*
SmoothSparseThetaConfig::mutable_alpha() {
  return &alpha_;
}

// -------------------------------------------------------------------

// SmoothSparsePhiConfig

// optional int32 background_topics_count = 1;
inline bool SmoothSparsePhiConfig::has_background_topics_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmoothSparsePhiConfig::set_has_background_topics_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmoothSparsePhiConfig::clear_has_background_topics_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmoothSparsePhiConfig::clear_background_topics_count() {
  background_topics_count_ = 0;
  clear_has_background_topics_count();
}
inline ::google::protobuf::int32 SmoothSparsePhiConfig::background_topics_count() const {
  return background_topics_count_;
}
inline void SmoothSparsePhiConfig::set_background_topics_count(::google::protobuf::int32 value) {
  set_has_background_topics_count();
  background_topics_count_ = value;
}

// optional .artm.BoolArray topics_to_regularize = 2;
inline bool SmoothSparsePhiConfig::has_topics_to_regularize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmoothSparsePhiConfig::set_has_topics_to_regularize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmoothSparsePhiConfig::clear_has_topics_to_regularize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmoothSparsePhiConfig::clear_topics_to_regularize() {
  if (topics_to_regularize_ != NULL) topics_to_regularize_->::artm::BoolArray::Clear();
  clear_has_topics_to_regularize();
}
inline const ::artm::BoolArray& SmoothSparsePhiConfig::topics_to_regularize() const {
  return topics_to_regularize_ != NULL ? *topics_to_regularize_ : *default_instance_->topics_to_regularize_;
}
inline ::artm::BoolArray* SmoothSparsePhiConfig::mutable_topics_to_regularize() {
  set_has_topics_to_regularize();
  if (topics_to_regularize_ == NULL) topics_to_regularize_ = new ::artm::BoolArray;
  return topics_to_regularize_;
}
inline ::artm::BoolArray* SmoothSparsePhiConfig::release_topics_to_regularize() {
  clear_has_topics_to_regularize();
  ::artm::BoolArray* temp = topics_to_regularize_;
  topics_to_regularize_ = NULL;
  return temp;
}
inline void SmoothSparsePhiConfig::set_allocated_topics_to_regularize(::artm::BoolArray* topics_to_regularize) {
  delete topics_to_regularize_;
  topics_to_regularize_ = topics_to_regularize;
  if (topics_to_regularize) {
    set_has_topics_to_regularize();
  } else {
    clear_has_topics_to_regularize();
  }
}

// optional string dictionary_name = 3;
inline bool SmoothSparsePhiConfig::has_dictionary_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmoothSparsePhiConfig::set_has_dictionary_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmoothSparsePhiConfig::clear_has_dictionary_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmoothSparsePhiConfig::clear_dictionary_name() {
  if (dictionary_name_ != &::google::protobuf::internal::kEmptyString) {
    dictionary_name_->clear();
  }
  clear_has_dictionary_name();
}
inline const ::std::string& SmoothSparsePhiConfig::dictionary_name() const {
  return *dictionary_name_;
}
inline void SmoothSparsePhiConfig::set_dictionary_name(const ::std::string& value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void SmoothSparsePhiConfig::set_dictionary_name(const char* value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void SmoothSparsePhiConfig::set_dictionary_name(const char* value, size_t size) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmoothSparsePhiConfig::mutable_dictionary_name() {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    dictionary_name_ = new ::std::string;
  }
  return dictionary_name_;
}
inline ::std::string* SmoothSparsePhiConfig::release_dictionary_name() {
  clear_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_name_;
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SmoothSparsePhiConfig::set_allocated_dictionary_name(::std::string* dictionary_name) {
  if (dictionary_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dictionary_name_;
  }
  if (dictionary_name) {
    set_has_dictionary_name();
    dictionary_name_ = dictionary_name;
  } else {
    clear_has_dictionary_name();
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DecorrelatorPhiConfig

// optional .artm.BoolArray topics_to_regularize = 1;
inline bool DecorrelatorPhiConfig::has_topics_to_regularize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecorrelatorPhiConfig::set_has_topics_to_regularize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecorrelatorPhiConfig::clear_has_topics_to_regularize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecorrelatorPhiConfig::clear_topics_to_regularize() {
  if (topics_to_regularize_ != NULL) topics_to_regularize_->::artm::BoolArray::Clear();
  clear_has_topics_to_regularize();
}
inline const ::artm::BoolArray& DecorrelatorPhiConfig::topics_to_regularize() const {
  return topics_to_regularize_ != NULL ? *topics_to_regularize_ : *default_instance_->topics_to_regularize_;
}
inline ::artm::BoolArray* DecorrelatorPhiConfig::mutable_topics_to_regularize() {
  set_has_topics_to_regularize();
  if (topics_to_regularize_ == NULL) topics_to_regularize_ = new ::artm::BoolArray;
  return topics_to_regularize_;
}
inline ::artm::BoolArray* DecorrelatorPhiConfig::release_topics_to_regularize() {
  clear_has_topics_to_regularize();
  ::artm::BoolArray* temp = topics_to_regularize_;
  topics_to_regularize_ = NULL;
  return temp;
}
inline void DecorrelatorPhiConfig::set_allocated_topics_to_regularize(::artm::BoolArray* topics_to_regularize) {
  delete topics_to_regularize_;
  topics_to_regularize_ = topics_to_regularize;
  if (topics_to_regularize) {
    set_has_topics_to_regularize();
  } else {
    clear_has_topics_to_regularize();
  }
}

// -------------------------------------------------------------------

// DictionaryConfig

// required string name = 1;
inline bool DictionaryConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DictionaryConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DictionaryConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DictionaryConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DictionaryConfig::name() const {
  return *name_;
}
inline void DictionaryConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DictionaryConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DictionaryConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DictionaryConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DictionaryConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DictionaryConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .artm.DictionaryEntry entry = 2;
inline int DictionaryConfig::entry_size() const {
  return entry_.size();
}
inline void DictionaryConfig::clear_entry() {
  entry_.Clear();
}
inline const ::artm::DictionaryEntry& DictionaryConfig::entry(int index) const {
  return entry_.Get(index);
}
inline ::artm::DictionaryEntry* DictionaryConfig::mutable_entry(int index) {
  return entry_.Mutable(index);
}
inline ::artm::DictionaryEntry* DictionaryConfig::add_entry() {
  return entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >&
DictionaryConfig::entry() const {
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >*
DictionaryConfig::mutable_entry() {
  return &entry_;
}

// -------------------------------------------------------------------

// DictionaryEntry

// required string key_token = 1;
inline bool DictionaryEntry::has_key_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DictionaryEntry::set_has_key_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DictionaryEntry::clear_has_key_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DictionaryEntry::clear_key_token() {
  if (key_token_ != &::google::protobuf::internal::kEmptyString) {
    key_token_->clear();
  }
  clear_has_key_token();
}
inline const ::std::string& DictionaryEntry::key_token() const {
  return *key_token_;
}
inline void DictionaryEntry::set_key_token(const ::std::string& value) {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::kEmptyString) {
    key_token_ = new ::std::string;
  }
  key_token_->assign(value);
}
inline void DictionaryEntry::set_key_token(const char* value) {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::kEmptyString) {
    key_token_ = new ::std::string;
  }
  key_token_->assign(value);
}
inline void DictionaryEntry::set_key_token(const char* value, size_t size) {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::kEmptyString) {
    key_token_ = new ::std::string;
  }
  key_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DictionaryEntry::mutable_key_token() {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::kEmptyString) {
    key_token_ = new ::std::string;
  }
  return key_token_;
}
inline ::std::string* DictionaryEntry::release_key_token() {
  clear_has_key_token();
  if (key_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_token_;
    key_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DictionaryEntry::set_allocated_key_token(::std::string* key_token) {
  if (key_token_ != &::google::protobuf::internal::kEmptyString) {
    delete key_token_;
  }
  if (key_token) {
    set_has_key_token();
    key_token_ = key_token;
  } else {
    clear_has_key_token();
    key_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float value = 2;
inline bool DictionaryEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DictionaryEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DictionaryEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DictionaryEntry::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float DictionaryEntry::value() const {
  return value_;
}
inline void DictionaryEntry::set_value(float value) {
  set_has_value();
  value_ = value;
}

// repeated string value_tokens = 3;
inline int DictionaryEntry::value_tokens_size() const {
  return value_tokens_.size();
}
inline void DictionaryEntry::clear_value_tokens() {
  value_tokens_.Clear();
}
inline const ::std::string& DictionaryEntry::value_tokens(int index) const {
  return value_tokens_.Get(index);
}
inline ::std::string* DictionaryEntry::mutable_value_tokens(int index) {
  return value_tokens_.Mutable(index);
}
inline void DictionaryEntry::set_value_tokens(int index, const ::std::string& value) {
  value_tokens_.Mutable(index)->assign(value);
}
inline void DictionaryEntry::set_value_tokens(int index, const char* value) {
  value_tokens_.Mutable(index)->assign(value);
}
inline void DictionaryEntry::set_value_tokens(int index, const char* value, size_t size) {
  value_tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DictionaryEntry::add_value_tokens() {
  return value_tokens_.Add();
}
inline void DictionaryEntry::add_value_tokens(const ::std::string& value) {
  value_tokens_.Add()->assign(value);
}
inline void DictionaryEntry::add_value_tokens(const char* value) {
  value_tokens_.Add()->assign(value);
}
inline void DictionaryEntry::add_value_tokens(const char* value, size_t size) {
  value_tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DictionaryEntry::value_tokens() const {
  return value_tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DictionaryEntry::mutable_value_tokens() {
  return &value_tokens_;
}

// optional .artm.FloatArray values = 4;
inline bool DictionaryEntry::has_values() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DictionaryEntry::set_has_values() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DictionaryEntry::clear_has_values() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DictionaryEntry::clear_values() {
  if (values_ != NULL) values_->::artm::FloatArray::Clear();
  clear_has_values();
}
inline const ::artm::FloatArray& DictionaryEntry::values() const {
  return values_ != NULL ? *values_ : *default_instance_->values_;
}
inline ::artm::FloatArray* DictionaryEntry::mutable_values() {
  set_has_values();
  if (values_ == NULL) values_ = new ::artm::FloatArray;
  return values_;
}
inline ::artm::FloatArray* DictionaryEntry::release_values() {
  clear_has_values();
  ::artm::FloatArray* temp = values_;
  values_ = NULL;
  return temp;
}
inline void DictionaryEntry::set_allocated_values(::artm::FloatArray* values) {
  delete values_;
  values_ = values;
  if (values) {
    set_has_values();
  } else {
    clear_has_values();
  }
}

// -------------------------------------------------------------------

// DoubleArray

// repeated double value = 1 [packed = true];
inline int DoubleArray::value_size() const {
  return value_.size();
}
inline void DoubleArray::clear_value() {
  value_.Clear();
}
inline double DoubleArray::value(int index) const {
  return value_.Get(index);
}
inline void DoubleArray::set_value(int index, double value) {
  value_.Set(index, value);
}
inline void DoubleArray::add_value(double value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// FloatArray

// repeated float value = 1 [packed = true];
inline int FloatArray::value_size() const {
  return value_.size();
}
inline void FloatArray::clear_value() {
  value_.Clear();
}
inline float FloatArray::value(int index) const {
  return value_.Get(index);
}
inline void FloatArray::set_value(int index, float value) {
  value_.Set(index, value);
}
inline void FloatArray::add_value(float value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
FloatArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// BoolArray

// repeated bool value = 1 [packed = true];
inline int BoolArray::value_size() const {
  return value_.size();
}
inline void BoolArray::clear_value() {
  value_.Clear();
}
inline bool BoolArray::value(int index) const {
  return value_.Get(index);
}
inline void BoolArray::set_value(int index, bool value) {
  value_.Set(index, value);
}
inline void BoolArray::add_value(bool value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
BoolArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< bool >*
BoolArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// ScoreConfig

// optional string name = 1;
inline bool ScoreConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ScoreConfig::name() const {
  return *name_;
}
inline void ScoreConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ScoreConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScoreConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .artm.ScoreConfig.Type type = 2;
inline bool ScoreConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::ScoreConfig_Type ScoreConfig::type() const {
  return static_cast< ::artm::ScoreConfig_Type >(type_);
}
inline void ScoreConfig::set_type(::artm::ScoreConfig_Type value) {
  assert(::artm::ScoreConfig_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes config = 3;
inline bool ScoreConfig::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScoreConfig::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScoreConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScoreConfig::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& ScoreConfig::config() const {
  return *config_;
}
inline void ScoreConfig::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void ScoreConfig::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void ScoreConfig::set_config(const void* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreConfig::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* ScoreConfig::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScoreConfig::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ScoreData

// optional string name = 1;
inline bool ScoreData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ScoreData::name() const {
  return *name_;
}
inline void ScoreData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ScoreData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScoreData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .artm.ScoreData.Type type = 2;
inline bool ScoreData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::ScoreData_Type ScoreData::type() const {
  return static_cast< ::artm::ScoreData_Type >(type_);
}
inline void ScoreData::set_type(::artm::ScoreData_Type value) {
  assert(::artm::ScoreData_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes data = 3;
inline bool ScoreData::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScoreData::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScoreData::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScoreData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ScoreData::data() const {
  return *data_;
}
inline void ScoreData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ScoreData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ScoreData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ScoreData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScoreData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PerplexityScoreConfig

// optional string field_name = 1 [default = "@body"];
inline bool PerplexityScoreConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerplexityScoreConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerplexityScoreConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerplexityScoreConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& PerplexityScoreConfig::field_name() const {
  return *field_name_;
}
inline void PerplexityScoreConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void PerplexityScoreConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void PerplexityScoreConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PerplexityScoreConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* PerplexityScoreConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void PerplexityScoreConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 2 [default = "@global"];
inline bool PerplexityScoreConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerplexityScoreConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerplexityScoreConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerplexityScoreConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& PerplexityScoreConfig::stream_name() const {
  return *stream_name_;
}
inline void PerplexityScoreConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void PerplexityScoreConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void PerplexityScoreConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PerplexityScoreConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* PerplexityScoreConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void PerplexityScoreConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// -------------------------------------------------------------------

// PerplexityScore

// optional double value = 1;
inline bool PerplexityScore::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerplexityScore::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerplexityScore::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerplexityScore::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double PerplexityScore::value() const {
  return value_;
}
inline void PerplexityScore::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional double raw = 2;
inline bool PerplexityScore::has_raw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerplexityScore::set_has_raw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerplexityScore::clear_has_raw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerplexityScore::clear_raw() {
  raw_ = 0;
  clear_has_raw();
}
inline double PerplexityScore::raw() const {
  return raw_;
}
inline void PerplexityScore::set_raw(double value) {
  set_has_raw();
  raw_ = value;
}

// optional double normalizer = 3;
inline bool PerplexityScore::has_normalizer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerplexityScore::set_has_normalizer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerplexityScore::clear_has_normalizer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerplexityScore::clear_normalizer() {
  normalizer_ = 0;
  clear_has_normalizer();
}
inline double PerplexityScore::normalizer() const {
  return normalizer_;
}
inline void PerplexityScore::set_normalizer(double value) {
  set_has_normalizer();
  normalizer_ = value;
}

// optional int32 zero_words = 4;
inline bool PerplexityScore::has_zero_words() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerplexityScore::set_has_zero_words() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerplexityScore::clear_has_zero_words() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerplexityScore::clear_zero_words() {
  zero_words_ = 0;
  clear_has_zero_words();
}
inline ::google::protobuf::int32 PerplexityScore::zero_words() const {
  return zero_words_;
}
inline void PerplexityScore::set_zero_words(::google::protobuf::int32 value) {
  set_has_zero_words();
  zero_words_ = value;
}

// -------------------------------------------------------------------

// TopicModel_TopicModelInternals

// repeated .artm.FloatArray n_wt = 1;
inline int TopicModel_TopicModelInternals::n_wt_size() const {
  return n_wt_.size();
}
inline void TopicModel_TopicModelInternals::clear_n_wt() {
  n_wt_.Clear();
}
inline const ::artm::FloatArray& TopicModel_TopicModelInternals::n_wt(int index) const {
  return n_wt_.Get(index);
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::mutable_n_wt(int index) {
  return n_wt_.Mutable(index);
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::add_n_wt() {
  return n_wt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
TopicModel_TopicModelInternals::n_wt() const {
  return n_wt_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
TopicModel_TopicModelInternals::mutable_n_wt() {
  return &n_wt_;
}

// repeated .artm.FloatArray r_wt = 2;
inline int TopicModel_TopicModelInternals::r_wt_size() const {
  return r_wt_.size();
}
inline void TopicModel_TopicModelInternals::clear_r_wt() {
  r_wt_.Clear();
}
inline const ::artm::FloatArray& TopicModel_TopicModelInternals::r_wt(int index) const {
  return r_wt_.Get(index);
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::mutable_r_wt(int index) {
  return r_wt_.Mutable(index);
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::add_r_wt() {
  return r_wt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
TopicModel_TopicModelInternals::r_wt() const {
  return r_wt_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
TopicModel_TopicModelInternals::mutable_r_wt() {
  return &r_wt_;
}

// optional .artm.FloatArray n_t = 3;
inline bool TopicModel_TopicModelInternals::has_n_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopicModel_TopicModelInternals::set_has_n_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopicModel_TopicModelInternals::clear_has_n_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopicModel_TopicModelInternals::clear_n_t() {
  if (n_t_ != NULL) n_t_->::artm::FloatArray::Clear();
  clear_has_n_t();
}
inline const ::artm::FloatArray& TopicModel_TopicModelInternals::n_t() const {
  return n_t_ != NULL ? *n_t_ : *default_instance_->n_t_;
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::mutable_n_t() {
  set_has_n_t();
  if (n_t_ == NULL) n_t_ = new ::artm::FloatArray;
  return n_t_;
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::release_n_t() {
  clear_has_n_t();
  ::artm::FloatArray* temp = n_t_;
  n_t_ = NULL;
  return temp;
}
inline void TopicModel_TopicModelInternals::set_allocated_n_t(::artm::FloatArray* n_t) {
  delete n_t_;
  n_t_ = n_t;
  if (n_t) {
    set_has_n_t();
  } else {
    clear_has_n_t();
  }
}

// -------------------------------------------------------------------

// TopicModel

// optional string name = 1 [default = "@model"];
inline bool TopicModel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicModel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicModel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicModel::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& TopicModel::name() const {
  return *name_;
}
inline void TopicModel::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TopicModel::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TopicModel::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* TopicModel::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void TopicModel::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// optional int32 topics_count = 2;
inline bool TopicModel::has_topics_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicModel::set_has_topics_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicModel::clear_has_topics_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicModel::clear_topics_count() {
  topics_count_ = 0;
  clear_has_topics_count();
}
inline ::google::protobuf::int32 TopicModel::topics_count() const {
  return topics_count_;
}
inline void TopicModel::set_topics_count(::google::protobuf::int32 value) {
  set_has_topics_count();
  topics_count_ = value;
}

// repeated string token = 3;
inline int TopicModel::token_size() const {
  return token_.size();
}
inline void TopicModel::clear_token() {
  token_.Clear();
}
inline const ::std::string& TopicModel::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* TopicModel::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void TopicModel::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void TopicModel::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void TopicModel::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::add_token() {
  return token_.Add();
}
inline void TopicModel::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void TopicModel::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void TopicModel::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopicModel::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopicModel::mutable_token() {
  return &token_;
}

// repeated .artm.FloatArray token_weights = 4;
inline int TopicModel::token_weights_size() const {
  return token_weights_.size();
}
inline void TopicModel::clear_token_weights() {
  token_weights_.Clear();
}
inline const ::artm::FloatArray& TopicModel::token_weights(int index) const {
  return token_weights_.Get(index);
}
inline ::artm::FloatArray* TopicModel::mutable_token_weights(int index) {
  return token_weights_.Mutable(index);
}
inline ::artm::FloatArray* TopicModel::add_token_weights() {
  return token_weights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
TopicModel::token_weights() const {
  return token_weights_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
TopicModel::mutable_token_weights() {
  return &token_weights_;
}

// optional bytes internals = 5;
inline bool TopicModel::has_internals() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopicModel::set_has_internals() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopicModel::clear_has_internals() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopicModel::clear_internals() {
  if (internals_ != &::google::protobuf::internal::kEmptyString) {
    internals_->clear();
  }
  clear_has_internals();
}
inline const ::std::string& TopicModel::internals() const {
  return *internals_;
}
inline void TopicModel::set_internals(const ::std::string& value) {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::kEmptyString) {
    internals_ = new ::std::string;
  }
  internals_->assign(value);
}
inline void TopicModel::set_internals(const char* value) {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::kEmptyString) {
    internals_ = new ::std::string;
  }
  internals_->assign(value);
}
inline void TopicModel::set_internals(const void* value, size_t size) {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::kEmptyString) {
    internals_ = new ::std::string;
  }
  internals_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::mutable_internals() {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::kEmptyString) {
    internals_ = new ::std::string;
  }
  return internals_;
}
inline ::std::string* TopicModel::release_internals() {
  clear_has_internals();
  if (internals_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internals_;
    internals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopicModel::set_allocated_internals(::std::string* internals) {
  if (internals_ != &::google::protobuf::internal::kEmptyString) {
    delete internals_;
  }
  if (internals) {
    set_has_internals();
    internals_ = internals;
  } else {
    clear_has_internals();
    internals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ThetaMatrix

// optional string model_name = 1 [default = "@model"];
inline bool ThetaMatrix::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThetaMatrix::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThetaMatrix::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThetaMatrix::clear_model_name() {
  if (model_name_ != _default_model_name_) {
    model_name_->assign(*_default_model_name_);
  }
  clear_has_model_name();
}
inline const ::std::string& ThetaMatrix::model_name() const {
  return *model_name_;
}
inline void ThetaMatrix::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ThetaMatrix::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ThetaMatrix::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThetaMatrix::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string(*_default_model_name_);
  }
  return model_name_;
}
inline ::std::string* ThetaMatrix::release_model_name() {
  clear_has_model_name();
  if (model_name_ == _default_model_name_) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(_default_model_name_);
    return temp;
  }
}
inline void ThetaMatrix::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != _default_model_name_) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(_default_model_name_);
  }
}

// repeated int32 item_id = 2;
inline int ThetaMatrix::item_id_size() const {
  return item_id_.size();
}
inline void ThetaMatrix::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::int32 ThetaMatrix::item_id(int index) const {
  return item_id_.Get(index);
}
inline void ThetaMatrix::set_item_id(int index, ::google::protobuf::int32 value) {
  item_id_.Set(index, value);
}
inline void ThetaMatrix::add_item_id(::google::protobuf::int32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ThetaMatrix::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ThetaMatrix::mutable_item_id() {
  return &item_id_;
}

// repeated .artm.FloatArray item_weights = 3;
inline int ThetaMatrix::item_weights_size() const {
  return item_weights_.size();
}
inline void ThetaMatrix::clear_item_weights() {
  item_weights_.Clear();
}
inline const ::artm::FloatArray& ThetaMatrix::item_weights(int index) const {
  return item_weights_.Get(index);
}
inline ::artm::FloatArray* ThetaMatrix::mutable_item_weights(int index) {
  return item_weights_.Mutable(index);
}
inline ::artm::FloatArray* ThetaMatrix::add_item_weights() {
  return item_weights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
ThetaMatrix::item_weights() const {
  return item_weights_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
ThetaMatrix::mutable_item_weights() {
  return &item_weights_;
}

// -------------------------------------------------------------------

// NodeControllerConfig

// optional string create_endpoint = 1;
inline bool NodeControllerConfig::has_create_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeControllerConfig::set_has_create_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeControllerConfig::clear_has_create_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeControllerConfig::clear_create_endpoint() {
  if (create_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    create_endpoint_->clear();
  }
  clear_has_create_endpoint();
}
inline const ::std::string& NodeControllerConfig::create_endpoint() const {
  return *create_endpoint_;
}
inline void NodeControllerConfig::set_create_endpoint(const ::std::string& value) {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  create_endpoint_->assign(value);
}
inline void NodeControllerConfig::set_create_endpoint(const char* value) {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  create_endpoint_->assign(value);
}
inline void NodeControllerConfig::set_create_endpoint(const char* value, size_t size) {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  create_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeControllerConfig::mutable_create_endpoint() {
  set_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    create_endpoint_ = new ::std::string;
  }
  return create_endpoint_;
}
inline ::std::string* NodeControllerConfig::release_create_endpoint() {
  clear_has_create_endpoint();
  if (create_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_endpoint_;
    create_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeControllerConfig::set_allocated_create_endpoint(::std::string* create_endpoint) {
  if (create_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete create_endpoint_;
  }
  if (create_endpoint) {
    set_has_create_endpoint();
    create_endpoint_ = create_endpoint;
  } else {
    clear_has_create_endpoint();
    create_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace artm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::Stream_Type>() {
  return ::artm::Stream_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::MasterComponentConfig_ModusOperandi>() {
  return ::artm::MasterComponentConfig_ModusOperandi_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::RegularizerConfig_Type>() {
  return ::artm::RegularizerConfig_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::ScoreConfig_Type>() {
  return ::artm::ScoreConfig_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::ScoreData_Type>() {
  return ::artm::ScoreData_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_artm_2fmessages_2eproto__INCLUDED
