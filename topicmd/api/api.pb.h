// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

#ifndef PROTOBUF_api_2eproto__INCLUDED
#define PROTOBUF_api_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace topicmd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_api_2eproto();
void protobuf_AssignDesc_api_2eproto();
void protobuf_ShutdownFile_api_2eproto();

class ItemsVector;
class ItemsVector_Item;
class Configuration;
class LoggerConfiguration;

enum ItemsVector_OperationType {
  ItemsVector_OperationType_INSERT = 0,
  ItemsVector_OperationType_UPDATE = 1,
  ItemsVector_OperationType_DELETE = 2
};
bool ItemsVector_OperationType_IsValid(int value);
const ItemsVector_OperationType ItemsVector_OperationType_OperationType_MIN = ItemsVector_OperationType_INSERT;
const ItemsVector_OperationType ItemsVector_OperationType_OperationType_MAX = ItemsVector_OperationType_DELETE;
const int ItemsVector_OperationType_OperationType_ARRAYSIZE = ItemsVector_OperationType_OperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ItemsVector_OperationType_descriptor();
inline const ::std::string& ItemsVector_OperationType_Name(ItemsVector_OperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ItemsVector_OperationType_descriptor(), value);
}
inline bool ItemsVector_OperationType_Parse(
    const ::std::string& name, ItemsVector_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemsVector_OperationType>(
    ItemsVector_OperationType_descriptor(), name, value);
}
enum Configuration_ProcessorType {
  Configuration_ProcessorType_BATCH_PLSA = 0
};
bool Configuration_ProcessorType_IsValid(int value);
const Configuration_ProcessorType Configuration_ProcessorType_ProcessorType_MIN = Configuration_ProcessorType_BATCH_PLSA;
const Configuration_ProcessorType Configuration_ProcessorType_ProcessorType_MAX = Configuration_ProcessorType_BATCH_PLSA;
const int Configuration_ProcessorType_ProcessorType_ARRAYSIZE = Configuration_ProcessorType_ProcessorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Configuration_ProcessorType_descriptor();
inline const ::std::string& Configuration_ProcessorType_Name(Configuration_ProcessorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Configuration_ProcessorType_descriptor(), value);
}
inline bool Configuration_ProcessorType_Parse(
    const ::std::string& name, Configuration_ProcessorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Configuration_ProcessorType>(
    Configuration_ProcessorType_descriptor(), name, value);
}
enum LoggerConfiguration_Level {
  LoggerConfiguration_Level_ERROR = 1,
  LoggerConfiguration_Level_WARNING = 2,
  LoggerConfiguration_Level_INFO = 3,
  LoggerConfiguration_Level_VERBOSE = 4
};
bool LoggerConfiguration_Level_IsValid(int value);
const LoggerConfiguration_Level LoggerConfiguration_Level_Level_MIN = LoggerConfiguration_Level_ERROR;
const LoggerConfiguration_Level LoggerConfiguration_Level_Level_MAX = LoggerConfiguration_Level_VERBOSE;
const int LoggerConfiguration_Level_Level_ARRAYSIZE = LoggerConfiguration_Level_Level_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoggerConfiguration_Level_descriptor();
inline const ::std::string& LoggerConfiguration_Level_Name(LoggerConfiguration_Level value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoggerConfiguration_Level_descriptor(), value);
}
inline bool LoggerConfiguration_Level_Parse(
    const ::std::string& name, LoggerConfiguration_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoggerConfiguration_Level>(
    LoggerConfiguration_Level_descriptor(), name, value);
}
enum ContractVersion {
  V_01 = 0
};
bool ContractVersion_IsValid(int value);
const ContractVersion ContractVersion_MIN = V_01;
const ContractVersion ContractVersion_MAX = V_01;
const int ContractVersion_ARRAYSIZE = ContractVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContractVersion_descriptor();
inline const ::std::string& ContractVersion_Name(ContractVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContractVersion_descriptor(), value);
}
inline bool ContractVersion_Parse(
    const ::std::string& name, ContractVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContractVersion>(
    ContractVersion_descriptor(), name, value);
}
// ===================================================================

class ItemsVector_Item : public ::google::protobuf::Message {
 public:
  ItemsVector_Item();
  virtual ~ItemsVector_Item();

  ItemsVector_Item(const ItemsVector_Item& from);

  inline ItemsVector_Item& operator=(const ItemsVector_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemsVector_Item& default_instance();

  void Swap(ItemsVector_Item* other);

  // implements Message ----------------------------------------------

  ItemsVector_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemsVector_Item& from);
  void MergeFrom(const ItemsVector_Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .topicmd.ItemsVector.OperationType operation = 2 [default = INSERT];
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::topicmd::ItemsVector_OperationType operation() const;
  inline void set_operation(::topicmd::ItemsVector_OperationType value);

  // repeated int32 token_ids = 3;
  inline int token_ids_size() const;
  inline void clear_token_ids();
  static const int kTokenIdsFieldNumber = 3;
  inline ::google::protobuf::int32 token_ids(int index) const;
  inline void set_token_ids(int index, ::google::protobuf::int32 value);
  inline void add_token_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_ids();

  // repeated int32 token_counts = 4;
  inline int token_counts_size() const;
  inline void clear_token_counts();
  static const int kTokenCountsFieldNumber = 4;
  inline ::google::protobuf::int32 token_counts(int index) const;
  inline void set_token_counts(int index, ::google::protobuf::int32 value);
  inline void add_token_counts(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_counts() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_counts();

  // @@protoc_insertion_point(class_scope:topicmd.ItemsVector.Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_operation();
  inline void clear_has_operation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  int operation_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_counts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ItemsVector_Item* default_instance_;
};
// -------------------------------------------------------------------

class ItemsVector : public ::google::protobuf::Message {
 public:
  ItemsVector();
  virtual ~ItemsVector();

  ItemsVector(const ItemsVector& from);

  inline ItemsVector& operator=(const ItemsVector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemsVector& default_instance();

  void Swap(ItemsVector* other);

  // implements Message ----------------------------------------------

  ItemsVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemsVector& from);
  void MergeFrom(const ItemsVector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ItemsVector_Item Item;

  typedef ItemsVector_OperationType OperationType;
  static const OperationType INSERT = ItemsVector_OperationType_INSERT;
  static const OperationType UPDATE = ItemsVector_OperationType_UPDATE;
  static const OperationType DELETE = ItemsVector_OperationType_DELETE;
  static inline bool OperationType_IsValid(int value) {
    return ItemsVector_OperationType_IsValid(value);
  }
  static const OperationType OperationType_MIN =
    ItemsVector_OperationType_OperationType_MIN;
  static const OperationType OperationType_MAX =
    ItemsVector_OperationType_OperationType_MAX;
  static const int OperationType_ARRAYSIZE =
    ItemsVector_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OperationType_descriptor() {
    return ItemsVector_OperationType_descriptor();
  }
  static inline const ::std::string& OperationType_Name(OperationType value) {
    return ItemsVector_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(const ::std::string& name,
      OperationType* value) {
    return ItemsVector_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
  inline bool has_contract_version() const;
  inline void clear_contract_version();
  static const int kContractVersionFieldNumber = 1;
  inline ::topicmd::ContractVersion contract_version() const;
  inline void set_contract_version(::topicmd::ContractVersion value);

  // repeated string tokens = 2;
  inline int tokens_size() const;
  inline void clear_tokens();
  static const int kTokensFieldNumber = 2;
  inline const ::std::string& tokens(int index) const;
  inline ::std::string* mutable_tokens(int index);
  inline void set_tokens(int index, const ::std::string& value);
  inline void set_tokens(int index, const char* value);
  inline void set_tokens(int index, const char* value, size_t size);
  inline ::std::string* add_tokens();
  inline void add_tokens(const ::std::string& value);
  inline void add_tokens(const char* value);
  inline void add_tokens(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();

  // repeated .topicmd.ItemsVector.Item items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::topicmd::ItemsVector_Item& items(int index) const;
  inline ::topicmd::ItemsVector_Item* mutable_items(int index);
  inline ::topicmd::ItemsVector_Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::topicmd::ItemsVector_Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::topicmd::ItemsVector_Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:topicmd.ItemsVector)
 private:
  inline void set_has_contract_version();
  inline void clear_has_contract_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
  ::google::protobuf::RepeatedPtrField< ::topicmd::ItemsVector_Item > items_;
  int contract_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ItemsVector* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Configuration_ProcessorType ProcessorType;
  static const ProcessorType BATCH_PLSA = Configuration_ProcessorType_BATCH_PLSA;
  static inline bool ProcessorType_IsValid(int value) {
    return Configuration_ProcessorType_IsValid(value);
  }
  static const ProcessorType ProcessorType_MIN =
    Configuration_ProcessorType_ProcessorType_MIN;
  static const ProcessorType ProcessorType_MAX =
    Configuration_ProcessorType_ProcessorType_MAX;
  static const int ProcessorType_ARRAYSIZE =
    Configuration_ProcessorType_ProcessorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProcessorType_descriptor() {
    return Configuration_ProcessorType_descriptor();
  }
  static inline const ::std::string& ProcessorType_Name(ProcessorType value) {
    return Configuration_ProcessorType_Name(value);
  }
  static inline bool ProcessorType_Parse(const ::std::string& name,
      ProcessorType* value) {
    return Configuration_ProcessorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
  inline bool has_contract_version() const;
  inline void clear_contract_version();
  static const int kContractVersionFieldNumber = 1;
  inline ::topicmd::ContractVersion contract_version() const;
  inline void set_contract_version(::topicmd::ContractVersion value);

  // optional string index_location = 2;
  inline bool has_index_location() const;
  inline void clear_index_location();
  static const int kIndexLocationFieldNumber = 2;
  inline const ::std::string& index_location() const;
  inline void set_index_location(const ::std::string& value);
  inline void set_index_location(const char* value);
  inline void set_index_location(const char* value, size_t size);
  inline ::std::string* mutable_index_location();
  inline ::std::string* release_index_location();
  inline void set_allocated_index_location(::std::string* index_location);

  // optional bool process_items_on_publish = 3 [default = false];
  inline bool has_process_items_on_publish() const;
  inline void clear_process_items_on_publish();
  static const int kProcessItemsOnPublishFieldNumber = 3;
  inline bool process_items_on_publish() const;
  inline void set_process_items_on_publish(bool value);

  // optional int32 index_readers_count = 4 [default = 1];
  inline bool has_index_readers_count() const;
  inline void clear_index_readers_count();
  static const int kIndexReadersCountFieldNumber = 4;
  inline ::google::protobuf::int32 index_readers_count() const;
  inline void set_index_readers_count(::google::protobuf::int32 value);

  // optional int32 processors_count = 5 [default = 1];
  inline bool has_processors_count() const;
  inline void clear_processors_count();
  static const int kProcessorsCountFieldNumber = 5;
  inline ::google::protobuf::int32 processors_count() const;
  inline void set_processors_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:topicmd.Configuration)
 private:
  inline void set_has_contract_version();
  inline void clear_has_contract_version();
  inline void set_has_index_location();
  inline void clear_has_index_location();
  inline void set_has_process_items_on_publish();
  inline void clear_has_process_items_on_publish();
  inline void set_has_index_readers_count();
  inline void clear_has_index_readers_count();
  inline void set_has_processors_count();
  inline void clear_has_processors_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* index_location_;
  int contract_version_;
  bool process_items_on_publish_;
  ::google::protobuf::int32 index_readers_count_;
  ::google::protobuf::int32 processors_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class LoggerConfiguration : public ::google::protobuf::Message {
 public:
  LoggerConfiguration();
  virtual ~LoggerConfiguration();

  LoggerConfiguration(const LoggerConfiguration& from);

  inline LoggerConfiguration& operator=(const LoggerConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggerConfiguration& default_instance();

  void Swap(LoggerConfiguration* other);

  // implements Message ----------------------------------------------

  LoggerConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoggerConfiguration& from);
  void MergeFrom(const LoggerConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoggerConfiguration_Level Level;
  static const Level ERROR = LoggerConfiguration_Level_ERROR;
  static const Level WARNING = LoggerConfiguration_Level_WARNING;
  static const Level INFO = LoggerConfiguration_Level_INFO;
  static const Level VERBOSE = LoggerConfiguration_Level_VERBOSE;
  static inline bool Level_IsValid(int value) {
    return LoggerConfiguration_Level_IsValid(value);
  }
  static const Level Level_MIN =
    LoggerConfiguration_Level_Level_MIN;
  static const Level Level_MAX =
    LoggerConfiguration_Level_Level_MAX;
  static const int Level_ARRAYSIZE =
    LoggerConfiguration_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Level_descriptor() {
    return LoggerConfiguration_Level_descriptor();
  }
  static inline const ::std::string& Level_Name(Level value) {
    return LoggerConfiguration_Level_Name(value);
  }
  static inline bool Level_Parse(const ::std::string& name,
      Level* value) {
    return LoggerConfiguration_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string log_location = 1;
  inline bool has_log_location() const;
  inline void clear_log_location();
  static const int kLogLocationFieldNumber = 1;
  inline const ::std::string& log_location() const;
  inline void set_log_location(const ::std::string& value);
  inline void set_log_location(const char* value);
  inline void set_log_location(const char* value, size_t size);
  inline ::std::string* mutable_log_location();
  inline ::std::string* release_log_location();
  inline void set_allocated_log_location(::std::string* log_location);

  // optional .topicmd.LoggerConfiguration.Level level = 2 [default = INFO];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::topicmd::LoggerConfiguration_Level level() const;
  inline void set_level(::topicmd::LoggerConfiguration_Level value);

  // @@protoc_insertion_point(class_scope:topicmd.LoggerConfiguration)
 private:
  inline void set_has_log_location();
  inline void clear_has_log_location();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* log_location_;
  int level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static LoggerConfiguration* default_instance_;
};
// ===================================================================


// ===================================================================

// ItemsVector_Item

// optional int32 id = 1;
inline bool ItemsVector_Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemsVector_Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemsVector_Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemsVector_Item::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ItemsVector_Item::id() const {
  return id_;
}
inline void ItemsVector_Item::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .topicmd.ItemsVector.OperationType operation = 2 [default = INSERT];
inline bool ItemsVector_Item::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemsVector_Item::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemsVector_Item::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemsVector_Item::clear_operation() {
  operation_ = 0;
  clear_has_operation();
}
inline ::topicmd::ItemsVector_OperationType ItemsVector_Item::operation() const {
  return static_cast< ::topicmd::ItemsVector_OperationType >(operation_);
}
inline void ItemsVector_Item::set_operation(::topicmd::ItemsVector_OperationType value) {
  assert(::topicmd::ItemsVector_OperationType_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// repeated int32 token_ids = 3;
inline int ItemsVector_Item::token_ids_size() const {
  return token_ids_.size();
}
inline void ItemsVector_Item::clear_token_ids() {
  token_ids_.Clear();
}
inline ::google::protobuf::int32 ItemsVector_Item::token_ids(int index) const {
  return token_ids_.Get(index);
}
inline void ItemsVector_Item::set_token_ids(int index, ::google::protobuf::int32 value) {
  token_ids_.Set(index, value);
}
inline void ItemsVector_Item::add_token_ids(::google::protobuf::int32 value) {
  token_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ItemsVector_Item::token_ids() const {
  return token_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ItemsVector_Item::mutable_token_ids() {
  return &token_ids_;
}

// repeated int32 token_counts = 4;
inline int ItemsVector_Item::token_counts_size() const {
  return token_counts_.size();
}
inline void ItemsVector_Item::clear_token_counts() {
  token_counts_.Clear();
}
inline ::google::protobuf::int32 ItemsVector_Item::token_counts(int index) const {
  return token_counts_.Get(index);
}
inline void ItemsVector_Item::set_token_counts(int index, ::google::protobuf::int32 value) {
  token_counts_.Set(index, value);
}
inline void ItemsVector_Item::add_token_counts(::google::protobuf::int32 value) {
  token_counts_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ItemsVector_Item::token_counts() const {
  return token_counts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ItemsVector_Item::mutable_token_counts() {
  return &token_counts_;
}

// -------------------------------------------------------------------

// ItemsVector

// optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
inline bool ItemsVector::has_contract_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemsVector::set_has_contract_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemsVector::clear_has_contract_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemsVector::clear_contract_version() {
  contract_version_ = 0;
  clear_has_contract_version();
}
inline ::topicmd::ContractVersion ItemsVector::contract_version() const {
  return static_cast< ::topicmd::ContractVersion >(contract_version_);
}
inline void ItemsVector::set_contract_version(::topicmd::ContractVersion value) {
  assert(::topicmd::ContractVersion_IsValid(value));
  set_has_contract_version();
  contract_version_ = value;
}

// repeated string tokens = 2;
inline int ItemsVector::tokens_size() const {
  return tokens_.size();
}
inline void ItemsVector::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& ItemsVector::tokens(int index) const {
  return tokens_.Get(index);
}
inline ::std::string* ItemsVector::mutable_tokens(int index) {
  return tokens_.Mutable(index);
}
inline void ItemsVector::set_tokens(int index, const ::std::string& value) {
  tokens_.Mutable(index)->assign(value);
}
inline void ItemsVector::set_tokens(int index, const char* value) {
  tokens_.Mutable(index)->assign(value);
}
inline void ItemsVector::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemsVector::add_tokens() {
  return tokens_.Add();
}
inline void ItemsVector::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
}
inline void ItemsVector::add_tokens(const char* value) {
  tokens_.Add()->assign(value);
}
inline void ItemsVector::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ItemsVector::tokens() const {
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ItemsVector::mutable_tokens() {
  return &tokens_;
}

// repeated .topicmd.ItemsVector.Item items = 3;
inline int ItemsVector::items_size() const {
  return items_.size();
}
inline void ItemsVector::clear_items() {
  items_.Clear();
}
inline const ::topicmd::ItemsVector_Item& ItemsVector::items(int index) const {
  return items_.Get(index);
}
inline ::topicmd::ItemsVector_Item* ItemsVector::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::topicmd::ItemsVector_Item* ItemsVector::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::topicmd::ItemsVector_Item >&
ItemsVector::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::topicmd::ItemsVector_Item >*
ItemsVector::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// Configuration

// optional .topicmd.ContractVersion contract_version = 1 [default = V_01];
inline bool Configuration::has_contract_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_contract_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_contract_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_contract_version() {
  contract_version_ = 0;
  clear_has_contract_version();
}
inline ::topicmd::ContractVersion Configuration::contract_version() const {
  return static_cast< ::topicmd::ContractVersion >(contract_version_);
}
inline void Configuration::set_contract_version(::topicmd::ContractVersion value) {
  assert(::topicmd::ContractVersion_IsValid(value));
  set_has_contract_version();
  contract_version_ = value;
}

// optional string index_location = 2;
inline bool Configuration::has_index_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_index_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_index_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_index_location() {
  if (index_location_ != &::google::protobuf::internal::kEmptyString) {
    index_location_->clear();
  }
  clear_has_index_location();
}
inline const ::std::string& Configuration::index_location() const {
  return *index_location_;
}
inline void Configuration::set_index_location(const ::std::string& value) {
  set_has_index_location();
  if (index_location_ == &::google::protobuf::internal::kEmptyString) {
    index_location_ = new ::std::string;
  }
  index_location_->assign(value);
}
inline void Configuration::set_index_location(const char* value) {
  set_has_index_location();
  if (index_location_ == &::google::protobuf::internal::kEmptyString) {
    index_location_ = new ::std::string;
  }
  index_location_->assign(value);
}
inline void Configuration::set_index_location(const char* value, size_t size) {
  set_has_index_location();
  if (index_location_ == &::google::protobuf::internal::kEmptyString) {
    index_location_ = new ::std::string;
  }
  index_location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Configuration::mutable_index_location() {
  set_has_index_location();
  if (index_location_ == &::google::protobuf::internal::kEmptyString) {
    index_location_ = new ::std::string;
  }
  return index_location_;
}
inline ::std::string* Configuration::release_index_location() {
  clear_has_index_location();
  if (index_location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index_location_;
    index_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Configuration::set_allocated_index_location(::std::string* index_location) {
  if (index_location_ != &::google::protobuf::internal::kEmptyString) {
    delete index_location_;
  }
  if (index_location) {
    set_has_index_location();
    index_location_ = index_location;
  } else {
    clear_has_index_location();
    index_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool process_items_on_publish = 3 [default = false];
inline bool Configuration::has_process_items_on_publish() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_process_items_on_publish() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_process_items_on_publish() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_process_items_on_publish() {
  process_items_on_publish_ = false;
  clear_has_process_items_on_publish();
}
inline bool Configuration::process_items_on_publish() const {
  return process_items_on_publish_;
}
inline void Configuration::set_process_items_on_publish(bool value) {
  set_has_process_items_on_publish();
  process_items_on_publish_ = value;
}

// optional int32 index_readers_count = 4 [default = 1];
inline bool Configuration::has_index_readers_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configuration::set_has_index_readers_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configuration::clear_has_index_readers_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configuration::clear_index_readers_count() {
  index_readers_count_ = 1;
  clear_has_index_readers_count();
}
inline ::google::protobuf::int32 Configuration::index_readers_count() const {
  return index_readers_count_;
}
inline void Configuration::set_index_readers_count(::google::protobuf::int32 value) {
  set_has_index_readers_count();
  index_readers_count_ = value;
}

// optional int32 processors_count = 5 [default = 1];
inline bool Configuration::has_processors_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configuration::set_has_processors_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configuration::clear_has_processors_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configuration::clear_processors_count() {
  processors_count_ = 1;
  clear_has_processors_count();
}
inline ::google::protobuf::int32 Configuration::processors_count() const {
  return processors_count_;
}
inline void Configuration::set_processors_count(::google::protobuf::int32 value) {
  set_has_processors_count();
  processors_count_ = value;
}

// -------------------------------------------------------------------

// LoggerConfiguration

// optional string log_location = 1;
inline bool LoggerConfiguration::has_log_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoggerConfiguration::set_has_log_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoggerConfiguration::clear_has_log_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoggerConfiguration::clear_log_location() {
  if (log_location_ != &::google::protobuf::internal::kEmptyString) {
    log_location_->clear();
  }
  clear_has_log_location();
}
inline const ::std::string& LoggerConfiguration::log_location() const {
  return *log_location_;
}
inline void LoggerConfiguration::set_log_location(const ::std::string& value) {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  log_location_->assign(value);
}
inline void LoggerConfiguration::set_log_location(const char* value) {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  log_location_->assign(value);
}
inline void LoggerConfiguration::set_log_location(const char* value, size_t size) {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  log_location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoggerConfiguration::mutable_log_location() {
  set_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    log_location_ = new ::std::string;
  }
  return log_location_;
}
inline ::std::string* LoggerConfiguration::release_log_location() {
  clear_has_log_location();
  if (log_location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_location_;
    log_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoggerConfiguration::set_allocated_log_location(::std::string* log_location) {
  if (log_location_ != &::google::protobuf::internal::kEmptyString) {
    delete log_location_;
  }
  if (log_location) {
    set_has_log_location();
    log_location_ = log_location;
  } else {
    clear_has_log_location();
    log_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .topicmd.LoggerConfiguration.Level level = 2 [default = INFO];
inline bool LoggerConfiguration::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoggerConfiguration::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoggerConfiguration::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoggerConfiguration::clear_level() {
  level_ = 3;
  clear_has_level();
}
inline ::topicmd::LoggerConfiguration_Level LoggerConfiguration::level() const {
  return static_cast< ::topicmd::LoggerConfiguration_Level >(level_);
}
inline void LoggerConfiguration::set_level(::topicmd::LoggerConfiguration_Level value) {
  assert(::topicmd::LoggerConfiguration_Level_IsValid(value));
  set_has_level();
  level_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace topicmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::topicmd::ItemsVector_OperationType>() {
  return ::topicmd::ItemsVector_OperationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::topicmd::Configuration_ProcessorType>() {
  return ::topicmd::Configuration_ProcessorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::topicmd::LoggerConfiguration_Level>() {
  return ::topicmd::LoggerConfiguration_Level_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::topicmd::ContractVersion>() {
  return ::topicmd::ContractVersion_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2eproto__INCLUDED
